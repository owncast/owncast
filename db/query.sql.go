// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const addAccessTokenForUser = `-- name: AddAccessTokenForUser :exec
INSERT INTO user_access_tokens(token, user_id) values($1, $2)
`

type AddAccessTokenForUserParams struct {
	Token  string
	UserID string
}

func (q *Queries) AddAccessTokenForUser(ctx context.Context, arg AddAccessTokenForUserParams) error {
	_, err := q.db.ExecContext(ctx, addAccessTokenForUser, arg.Token, arg.UserID)
	return err
}

const addAuthForUser = `-- name: AddAuthForUser :exec
INSERT INTO auth(user_id, token, type) values($1, $2, $3)
`

type AddAuthForUserParams struct {
	UserID string
	Token  string
	Type   string
}

func (q *Queries) AddAuthForUser(ctx context.Context, arg AddAuthForUserParams) error {
	_, err := q.db.ExecContext(ctx, addAuthForUser, arg.UserID, arg.Token, arg.Type)
	return err
}

const addFollower = `-- name: AddFollower :exec
INSERT INTO ap_followers(iri, inbox, request, request_object, name, username, image, approved_at) values($1, $2, $3, $4, $5, $6, $7, $8)
`

type AddFollowerParams struct {
	Iri           string
	Inbox         string
	Request       string
	RequestObject []byte
	Name          sql.NullString
	Username      string
	Image         sql.NullString
	ApprovedAt    sql.NullTime
}

func (q *Queries) AddFollower(ctx context.Context, arg AddFollowerParams) error {
	_, err := q.db.ExecContext(ctx, addFollower,
		arg.Iri,
		arg.Inbox,
		arg.Request,
		arg.RequestObject,
		arg.Name,
		arg.Username,
		arg.Image,
		arg.ApprovedAt,
	)
	return err
}

const addNotification = `-- name: AddNotification :exec
INSERT INTO notifications (channel, destination) VALUES($1, $2)
`

type AddNotificationParams struct {
	Channel     string
	Destination string
}

func (q *Queries) AddNotification(ctx context.Context, arg AddNotificationParams) error {
	_, err := q.db.ExecContext(ctx, addNotification, arg.Channel, arg.Destination)
	return err
}

const addToAcceptedActivities = `-- name: AddToAcceptedActivities :exec
INSERT INTO ap_accepted_activities(iri, actor, type, timestamp) values($1, $2, $3, $4)
`

type AddToAcceptedActivitiesParams struct {
	Iri       string
	Actor     string
	Type      string
	Timestamp time.Time
}

func (q *Queries) AddToAcceptedActivities(ctx context.Context, arg AddToAcceptedActivitiesParams) error {
	_, err := q.db.ExecContext(ctx, addToAcceptedActivities,
		arg.Iri,
		arg.Actor,
		arg.Type,
		arg.Timestamp,
	)
	return err
}

const addToOutbox = `-- name: AddToOutbox :exec
INSERT INTO ap_outbox(iri, value, type, live_notification) values($1, $2, $3, $4)
`

type AddToOutboxParams struct {
	Iri              string
	Value            []byte
	Type             string
	LiveNotification sql.NullBool
}

func (q *Queries) AddToOutbox(ctx context.Context, arg AddToOutboxParams) error {
	_, err := q.db.ExecContext(ctx, addToOutbox,
		arg.Iri,
		arg.Value,
		arg.Type,
		arg.LiveNotification,
	)
	return err
}

const approveFederationFollower = `-- name: ApproveFederationFollower :exec
UPDATE ap_followers SET approved_at = $1, disabled_at = null WHERE iri = $2
`

type ApproveFederationFollowerParams struct {
	ApprovedAt sql.NullTime
	Iri        string
}

func (q *Queries) ApproveFederationFollower(ctx context.Context, arg ApproveFederationFollowerParams) error {
	_, err := q.db.ExecContext(ctx, approveFederationFollower, arg.ApprovedAt, arg.Iri)
	return err
}

const banIPAddress = `-- name: BanIPAddress :exec
INSERT INTO ip_bans(ip_address, notes) values($1, $2)
`

type BanIPAddressParams struct {
	IpAddress string
	Notes     sql.NullString
}

func (q *Queries) BanIPAddress(ctx context.Context, arg BanIPAddressParams) error {
	_, err := q.db.ExecContext(ctx, banIPAddress, arg.IpAddress, arg.Notes)
	return err
}

const changeDisplayColor = `-- name: ChangeDisplayColor :exec
UPDATE users SET display_color = $1 WHERE id = $2
`

type ChangeDisplayColorParams struct {
	DisplayColor int32
	ID           string
}

func (q *Queries) ChangeDisplayColor(ctx context.Context, arg ChangeDisplayColorParams) error {
	_, err := q.db.ExecContext(ctx, changeDisplayColor, arg.DisplayColor, arg.ID)
	return err
}

const changeDisplayName = `-- name: ChangeDisplayName :exec
UPDATE users SET display_name = $1, previous_names = previous_names || $2, namechanged_at = $3 WHERE id = $4
`

type ChangeDisplayNameParams struct {
	DisplayName   string
	PreviousNames sql.NullString
	NamechangedAt sql.NullTime
	ID            string
}

func (q *Queries) ChangeDisplayName(ctx context.Context, arg ChangeDisplayNameParams) error {
	_, err := q.db.ExecContext(ctx, changeDisplayName,
		arg.DisplayName,
		arg.PreviousNames,
		arg.NamechangedAt,
		arg.ID,
	)
	return err
}

const doesInboundActivityExist = `-- name: DoesInboundActivityExist :one
SELECT count(*) FROM ap_accepted_activities WHERE iri = $1 AND actor = $2 AND TYPE = $3
`

type DoesInboundActivityExistParams struct {
	Iri   string
	Actor string
	Type  string
}

func (q *Queries) DoesInboundActivityExist(ctx context.Context, arg DoesInboundActivityExistParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, doesInboundActivityExist, arg.Iri, arg.Actor, arg.Type)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllClips = `-- name: GetAllClips :many
SELECT rc.id AS id, rc.clip_title, rc.stream_id, rc.relative_start_time, rc.relative_end_time, (rc.relative_end_time - rc.relative_start_time) AS duration_seconds, rc.timestamp, s.stream_title AS stream_title
	FROM replay_clips rc
	JOIN streams s ON rc.stream_id = s.id
	ORDER BY timestamp DESC
`

type GetAllClipsRow struct {
	ID                string
	ClipTitle         sql.NullString
	StreamID          string
	RelativeStartTime sql.NullFloat64
	RelativeEndTime   sql.NullFloat64
	DurationSeconds   int32
	Timestamp         sql.NullTime
	StreamTitle       sql.NullString
}

func (q *Queries) GetAllClips(ctx context.Context) ([]GetAllClipsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllClips)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllClipsRow
	for rows.Next() {
		var i GetAllClipsRow
		if err := rows.Scan(
			&i.ID,
			&i.ClipTitle,
			&i.StreamID,
			&i.RelativeStartTime,
			&i.RelativeEndTime,
			&i.DurationSeconds,
			&i.Timestamp,
			&i.StreamTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllClipsForStream = `-- name: GetAllClipsForStream :many
SELECT rc.id AS clip_id, rc.stream_id, rc.clipped_by, rc.clip_title, rc.relative_start_time, rc.relative_end_time, rc.timestamp,
	s.id AS stream_id, s.stream_title AS stream_title
	FROM replay_clips rc
	JOIN streams s ON rc.stream_id = s.id
	WHERE rc.stream_id = $1
	ORDER BY timestamp DESC
`

type GetAllClipsForStreamRow struct {
	ClipID            string
	StreamID          string
	ClippedBy         sql.NullString
	ClipTitle         sql.NullString
	RelativeStartTime sql.NullFloat64
	RelativeEndTime   sql.NullFloat64
	Timestamp         sql.NullTime
	StreamID_2        string
	StreamTitle       sql.NullString
}

func (q *Queries) GetAllClipsForStream(ctx context.Context, streamID string) ([]GetAllClipsForStreamRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllClipsForStream, streamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllClipsForStreamRow
	for rows.Next() {
		var i GetAllClipsForStreamRow
		if err := rows.Scan(
			&i.ClipID,
			&i.StreamID,
			&i.ClippedBy,
			&i.ClipTitle,
			&i.RelativeStartTime,
			&i.RelativeEndTime,
			&i.Timestamp,
			&i.StreamID_2,
			&i.StreamTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClip = `-- name: GetClip :one
SELECT id AS clip_id, stream_id, clipped_by, clip_title, timestamp AS clip_timestamp, relative_start_time, relative_end_time FROM replay_clips WHERE id = $1
`

type GetClipRow struct {
	ClipID            string
	StreamID          string
	ClippedBy         sql.NullString
	ClipTitle         sql.NullString
	ClipTimestamp     sql.NullTime
	RelativeStartTime sql.NullFloat64
	RelativeEndTime   sql.NullFloat64
}

func (q *Queries) GetClip(ctx context.Context, id string) (GetClipRow, error) {
	row := q.db.QueryRowContext(ctx, getClip, id)
	var i GetClipRow
	err := row.Scan(
		&i.ClipID,
		&i.StreamID,
		&i.ClippedBy,
		&i.ClipTitle,
		&i.ClipTimestamp,
		&i.RelativeStartTime,
		&i.RelativeEndTime,
	)
	return i, err
}

const getFederationFollowerApprovalRequests = `-- name: GetFederationFollowerApprovalRequests :many
SELECT iri, inbox, name, username, image, created_at FROM ap_followers WHERE approved_at IS null AND disabled_at is null
`

type GetFederationFollowerApprovalRequestsRow struct {
	Iri       string
	Inbox     string
	Name      sql.NullString
	Username  string
	Image     sql.NullString
	CreatedAt sql.NullTime
}

func (q *Queries) GetFederationFollowerApprovalRequests(ctx context.Context) ([]GetFederationFollowerApprovalRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getFederationFollowerApprovalRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFederationFollowerApprovalRequestsRow
	for rows.Next() {
		var i GetFederationFollowerApprovalRequestsRow
		if err := rows.Scan(
			&i.Iri,
			&i.Inbox,
			&i.Name,
			&i.Username,
			&i.Image,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFederationFollowersWithOffset = `-- name: GetFederationFollowersWithOffset :many
SELECT iri, inbox, name, username, image, created_at FROM ap_followers WHERE approved_at is not null ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type GetFederationFollowersWithOffsetParams struct {
	Limit  int32
	Offset int32
}

type GetFederationFollowersWithOffsetRow struct {
	Iri       string
	Inbox     string
	Name      sql.NullString
	Username  string
	Image     sql.NullString
	CreatedAt sql.NullTime
}

func (q *Queries) GetFederationFollowersWithOffset(ctx context.Context, arg GetFederationFollowersWithOffsetParams) ([]GetFederationFollowersWithOffsetRow, error) {
	rows, err := q.db.QueryContext(ctx, getFederationFollowersWithOffset, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFederationFollowersWithOffsetRow
	for rows.Next() {
		var i GetFederationFollowersWithOffsetRow
		if err := rows.Scan(
			&i.Iri,
			&i.Inbox,
			&i.Name,
			&i.Username,
			&i.Image,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFinalSegmentForStream = `-- name: GetFinalSegmentForStream :one
SELECT id, stream_id, output_configuration_id, path, relative_timestamp, timestamp FROM video_segments WHERE stream_id = $1 ORDER BY relative_timestamp DESC LIMIT 1
`

func (q *Queries) GetFinalSegmentForStream(ctx context.Context, streamID string) (VideoSegment, error) {
	row := q.db.QueryRowContext(ctx, getFinalSegmentForStream, streamID)
	var i VideoSegment
	err := row.Scan(
		&i.ID,
		&i.StreamID,
		&i.OutputConfigurationID,
		&i.Path,
		&i.RelativeTimestamp,
		&i.Timestamp,
	)
	return i, err
}

const getFollowerByIRI = `-- name: GetFollowerByIRI :one
SELECT iri, inbox, name, username, image, request, request_object, created_at, approved_at, disabled_at FROM ap_followers WHERE iri = $1
`

func (q *Queries) GetFollowerByIRI(ctx context.Context, iri string) (ApFollower, error) {
	row := q.db.QueryRowContext(ctx, getFollowerByIRI, iri)
	var i ApFollower
	err := row.Scan(
		&i.Iri,
		&i.Inbox,
		&i.Name,
		&i.Username,
		&i.Image,
		&i.Request,
		&i.RequestObject,
		&i.CreatedAt,
		&i.ApprovedAt,
		&i.DisabledAt,
	)
	return i, err
}

const getFollowerCount = `-- name: GetFollowerCount :one


SElECT count(*) FROM ap_followers WHERE approved_at is not null
`

// Queries added to query.sql must be compiled into Go code with sqlc. Read README.md for details.
// Federation related queries.
func (q *Queries) GetFollowerCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getFollowerCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getIPAddressBans = `-- name: GetIPAddressBans :many
SELECT ip_address, notes, created_at FROM ip_bans
`

func (q *Queries) GetIPAddressBans(ctx context.Context) ([]IpBan, error) {
	rows, err := q.db.QueryContext(ctx, getIPAddressBans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IpBan
	for rows.Next() {
		var i IpBan
		if err := rows.Scan(&i.IpAddress, &i.Notes, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInboundActivitiesWithOffset = `-- name: GetInboundActivitiesWithOffset :many
SELECT iri, actor, type, timestamp FROM ap_accepted_activities ORDER BY timestamp DESC LIMIT $1 OFFSET $2
`

type GetInboundActivitiesWithOffsetParams struct {
	Limit  int32
	Offset int32
}

type GetInboundActivitiesWithOffsetRow struct {
	Iri       string
	Actor     string
	Type      string
	Timestamp time.Time
}

func (q *Queries) GetInboundActivitiesWithOffset(ctx context.Context, arg GetInboundActivitiesWithOffsetParams) ([]GetInboundActivitiesWithOffsetRow, error) {
	rows, err := q.db.QueryContext(ctx, getInboundActivitiesWithOffset, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInboundActivitiesWithOffsetRow
	for rows.Next() {
		var i GetInboundActivitiesWithOffsetRow
		if err := rows.Scan(
			&i.Iri,
			&i.Actor,
			&i.Type,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInboundActivityCount = `-- name: GetInboundActivityCount :one
SELECT count(*) FROM ap_accepted_activities
`

func (q *Queries) GetInboundActivityCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getInboundActivityCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLocalPostCount = `-- name: GetLocalPostCount :one
SElECT count(*) FROM ap_outbox
`

func (q *Queries) GetLocalPostCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getLocalPostCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getMessagesFromUser = `-- name: GetMessagesFromUser :many
SELECT id, body, hidden_at, timestamp FROM messages WHERE eventType = 'CHAT' AND user_id = $1 ORDER BY TIMESTAMP DESC
`

type GetMessagesFromUserRow struct {
	ID        string
	Body      sql.NullString
	HiddenAt  sql.NullTime
	Timestamp sql.NullTime
}

func (q *Queries) GetMessagesFromUser(ctx context.Context, userID sql.NullString) ([]GetMessagesFromUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getMessagesFromUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMessagesFromUserRow
	for rows.Next() {
		var i GetMessagesFromUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Body,
			&i.HiddenAt,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationDestinationsForChannel = `-- name: GetNotificationDestinationsForChannel :many
SELECT destination FROM notifications WHERE channel = $1
`

func (q *Queries) GetNotificationDestinationsForChannel(ctx context.Context, channel string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getNotificationDestinationsForChannel, channel)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var destination string
		if err := rows.Scan(&destination); err != nil {
			return nil, err
		}
		items = append(items, destination)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getObjectFromOutboxByIRI = `-- name: GetObjectFromOutboxByIRI :one
SELECT value, live_notification, created_at FROM ap_outbox WHERE iri = $1
`

type GetObjectFromOutboxByIRIRow struct {
	Value            []byte
	LiveNotification sql.NullBool
	CreatedAt        sql.NullTime
}

func (q *Queries) GetObjectFromOutboxByIRI(ctx context.Context, iri string) (GetObjectFromOutboxByIRIRow, error) {
	row := q.db.QueryRowContext(ctx, getObjectFromOutboxByIRI, iri)
	var i GetObjectFromOutboxByIRIRow
	err := row.Scan(&i.Value, &i.LiveNotification, &i.CreatedAt)
	return i, err
}

const getOutboxWithOffset = `-- name: GetOutboxWithOffset :many
SELECT value FROM ap_outbox LIMIT $1 OFFSET $2
`

type GetOutboxWithOffsetParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetOutboxWithOffset(ctx context.Context, arg GetOutboxWithOffsetParams) ([][]byte, error) {
	rows, err := q.db.QueryContext(ctx, getOutboxWithOffset, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items [][]byte
	for rows.Next() {
		var value []byte
		if err := rows.Scan(&value); err != nil {
			return nil, err
		}
		items = append(items, value)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOutputConfigurationForId = `-- name: GetOutputConfigurationForId :one
SELECT id, stream_id, variant_id, name, segment_duration, bitrate, framerate, resolution_width, resolution_height FROM video_segment_output_configuration WHERE id = $1
`

type GetOutputConfigurationForIdRow struct {
	ID               string
	StreamID         string
	VariantID        string
	Name             string
	SegmentDuration  int32
	Bitrate          int32
	Framerate        int32
	ResolutionWidth  sql.NullInt32
	ResolutionHeight sql.NullInt32
}

func (q *Queries) GetOutputConfigurationForId(ctx context.Context, id string) (GetOutputConfigurationForIdRow, error) {
	row := q.db.QueryRowContext(ctx, getOutputConfigurationForId, id)
	var i GetOutputConfigurationForIdRow
	err := row.Scan(
		&i.ID,
		&i.StreamID,
		&i.VariantID,
		&i.Name,
		&i.SegmentDuration,
		&i.Bitrate,
		&i.Framerate,
		&i.ResolutionWidth,
		&i.ResolutionHeight,
	)
	return i, err
}

const getOutputConfigurationsForStreamId = `-- name: GetOutputConfigurationsForStreamId :many
SELECT id, stream_id, variant_id, name, segment_duration, bitrate, framerate, resolution_width, resolution_height FROM video_segment_output_configuration WHERE stream_id = $1
`

type GetOutputConfigurationsForStreamIdRow struct {
	ID               string
	StreamID         string
	VariantID        string
	Name             string
	SegmentDuration  int32
	Bitrate          int32
	Framerate        int32
	ResolutionWidth  sql.NullInt32
	ResolutionHeight sql.NullInt32
}

func (q *Queries) GetOutputConfigurationsForStreamId(ctx context.Context, streamID string) ([]GetOutputConfigurationsForStreamIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getOutputConfigurationsForStreamId, streamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOutputConfigurationsForStreamIdRow
	for rows.Next() {
		var i GetOutputConfigurationsForStreamIdRow
		if err := rows.Scan(
			&i.ID,
			&i.StreamID,
			&i.VariantID,
			&i.Name,
			&i.SegmentDuration,
			&i.Bitrate,
			&i.Framerate,
			&i.ResolutionWidth,
			&i.ResolutionHeight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRejectedAndBlockedFollowers = `-- name: GetRejectedAndBlockedFollowers :many
SELECT iri, name, username, image, created_at, disabled_at FROM ap_followers WHERE disabled_at is not null
`

type GetRejectedAndBlockedFollowersRow struct {
	Iri        string
	Name       sql.NullString
	Username   string
	Image      sql.NullString
	CreatedAt  sql.NullTime
	DisabledAt sql.NullTime
}

func (q *Queries) GetRejectedAndBlockedFollowers(ctx context.Context) ([]GetRejectedAndBlockedFollowersRow, error) {
	rows, err := q.db.QueryContext(ctx, getRejectedAndBlockedFollowers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRejectedAndBlockedFollowersRow
	for rows.Next() {
		var i GetRejectedAndBlockedFollowersRow
		if err := rows.Scan(
			&i.Iri,
			&i.Name,
			&i.Username,
			&i.Image,
			&i.CreatedAt,
			&i.DisabledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSegmentsForOutputId = `-- name: GetSegmentsForOutputId :many
SELECT id, stream_id, output_configuration_id, path, timestamp FROM video_segments WHERE output_configuration_id = $1 ORDER BY timestamp ASC
`

type GetSegmentsForOutputIdRow struct {
	ID                    string
	StreamID              string
	OutputConfigurationID string
	Path                  string
	Timestamp             sql.NullTime
}

func (q *Queries) GetSegmentsForOutputId(ctx context.Context, outputConfigurationID string) ([]GetSegmentsForOutputIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getSegmentsForOutputId, outputConfigurationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSegmentsForOutputIdRow
	for rows.Next() {
		var i GetSegmentsForOutputIdRow
		if err := rows.Scan(
			&i.ID,
			&i.StreamID,
			&i.OutputConfigurationID,
			&i.Path,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSegmentsForOutputIdAndWindow = `-- name: GetSegmentsForOutputIdAndWindow :many
SELECT id, stream_id, output_configuration_id, path, relative_timestamp, timestamp FROM video_segments WHERE output_configuration_id = $1 AND (cast ( relative_timestamp as int ) - ( relative_timestamp < cast ( relative_timestamp as int ))) >= $2::REAL AND (cast ( relative_timestamp as int ) + ( relative_timestamp > cast ( relative_timestamp as int ))) <= $3::REAL ORDER BY relative_timestamp ASC
`

type GetSegmentsForOutputIdAndWindowParams struct {
	OutputConfigurationID string
	StartSeconds          float32
	EndSeconds            float32
}

func (q *Queries) GetSegmentsForOutputIdAndWindow(ctx context.Context, arg GetSegmentsForOutputIdAndWindowParams) ([]VideoSegment, error) {
	rows, err := q.db.QueryContext(ctx, getSegmentsForOutputIdAndWindow, arg.OutputConfigurationID, arg.StartSeconds, arg.EndSeconds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VideoSegment
	for rows.Next() {
		var i VideoSegment
		if err := rows.Scan(
			&i.ID,
			&i.StreamID,
			&i.OutputConfigurationID,
			&i.Path,
			&i.RelativeTimestamp,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStreamById = `-- name: GetStreamById :one
SELECT id, stream_title, start_time, end_time FROM streams WHERE id = $1 LIMIT 1
`

func (q *Queries) GetStreamById(ctx context.Context, id string) (Stream, error) {
	row := q.db.QueryRowContext(ctx, getStreamById, id)
	var i Stream
	err := row.Scan(
		&i.ID,
		&i.StreamTitle,
		&i.StartTime,
		&i.EndTime,
	)
	return i, err
}

const getStreams = `-- name: GetStreams :many

SELECT id, stream_title, start_time, end_time FROM streams ORDER BY start_time DESC
`

// Recording and clip related queries.
func (q *Queries) GetStreams(ctx context.Context) ([]Stream, error) {
	rows, err := q.db.QueryContext(ctx, getStreams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stream
	for rows.Next() {
		var i Stream
		if err := rows.Scan(
			&i.ID,
			&i.StreamTitle,
			&i.StartTime,
			&i.EndTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByAccessToken = `-- name: GetUserByAccessToken :one
SELECT users.id, display_name, display_color, users.created_at, disabled_at, previous_names, namechanged_at, authenticated_at, scopes FROM users, user_access_tokens WHERE token = $1 AND users.id = user_id
`

type GetUserByAccessTokenRow struct {
	ID              string
	DisplayName     string
	DisplayColor    int32
	CreatedAt       sql.NullTime
	DisabledAt      sql.NullTime
	PreviousNames   sql.NullString
	NamechangedAt   sql.NullTime
	AuthenticatedAt sql.NullTime
	Scopes          sql.NullString
}

func (q *Queries) GetUserByAccessToken(ctx context.Context, token string) (GetUserByAccessTokenRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByAccessToken, token)
	var i GetUserByAccessTokenRow
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.DisplayColor,
		&i.CreatedAt,
		&i.DisabledAt,
		&i.PreviousNames,
		&i.NamechangedAt,
		&i.AuthenticatedAt,
		&i.Scopes,
	)
	return i, err
}

const getUserByAuth = `-- name: GetUserByAuth :one
SELECT users.id, display_name, display_color, users.created_at, disabled_at, previous_names, namechanged_at, authenticated_at, scopes FROM auth, users WHERE token = $1 AND auth.type = $2 AND users.id = auth.user_id
`

type GetUserByAuthParams struct {
	Token string
	Type  string
}

type GetUserByAuthRow struct {
	ID              string
	DisplayName     string
	DisplayColor    int32
	CreatedAt       sql.NullTime
	DisabledAt      sql.NullTime
	PreviousNames   sql.NullString
	NamechangedAt   sql.NullTime
	AuthenticatedAt sql.NullTime
	Scopes          sql.NullString
}

func (q *Queries) GetUserByAuth(ctx context.Context, arg GetUserByAuthParams) (GetUserByAuthRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByAuth, arg.Token, arg.Type)
	var i GetUserByAuthRow
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.DisplayColor,
		&i.CreatedAt,
		&i.DisabledAt,
		&i.PreviousNames,
		&i.NamechangedAt,
		&i.AuthenticatedAt,
		&i.Scopes,
	)
	return i, err
}

const getUserDisplayNameByToken = `-- name: GetUserDisplayNameByToken :one
SELECT display_name FROM users, user_access_tokens WHERE token = $1 AND users.id = user_id AND disabled_at = NULL
`

func (q *Queries) GetUserDisplayNameByToken(ctx context.Context, token string) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserDisplayNameByToken, token)
	var display_name string
	err := row.Scan(&display_name)
	return display_name, err
}

const insertClip = `-- name: InsertClip :exec
INSERT INTO replay_clips (id, stream_id, clip_title, relative_start_time, relative_end_time, timestamp) VALUES($1, $2, $3, $4, $5, $6)
`

type InsertClipParams struct {
	ID                string
	StreamID          string
	ClipTitle         sql.NullString
	RelativeStartTime sql.NullFloat64
	RelativeEndTime   sql.NullFloat64
	Timestamp         sql.NullTime
}

func (q *Queries) InsertClip(ctx context.Context, arg InsertClipParams) error {
	_, err := q.db.ExecContext(ctx, insertClip,
		arg.ID,
		arg.StreamID,
		arg.ClipTitle,
		arg.RelativeStartTime,
		arg.RelativeEndTime,
		arg.Timestamp,
	)
	return err
}

const insertOutputConfiguration = `-- name: InsertOutputConfiguration :exec
INSERT INTO video_segment_output_configuration (id, variant_id, stream_id, name, segment_duration, bitrate, framerate, resolution_width, resolution_height, timestamp) VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
`

type InsertOutputConfigurationParams struct {
	ID               string
	VariantID        string
	StreamID         string
	Name             string
	SegmentDuration  int32
	Bitrate          int32
	Framerate        int32
	ResolutionWidth  sql.NullInt32
	ResolutionHeight sql.NullInt32
	Timestamp        sql.NullTime
}

func (q *Queries) InsertOutputConfiguration(ctx context.Context, arg InsertOutputConfigurationParams) error {
	_, err := q.db.ExecContext(ctx, insertOutputConfiguration,
		arg.ID,
		arg.VariantID,
		arg.StreamID,
		arg.Name,
		arg.SegmentDuration,
		arg.Bitrate,
		arg.Framerate,
		arg.ResolutionWidth,
		arg.ResolutionHeight,
		arg.Timestamp,
	)
	return err
}

const insertSegment = `-- name: InsertSegment :exec
INSERT INTO video_segments (id, stream_id, output_configuration_id, path, relative_timestamp, timestamp) VALUES($1, $2, $3, $4, $5, $6)
`

type InsertSegmentParams struct {
	ID                    string
	StreamID              string
	OutputConfigurationID string
	Path                  string
	RelativeTimestamp     float32
	Timestamp             sql.NullTime
}

func (q *Queries) InsertSegment(ctx context.Context, arg InsertSegmentParams) error {
	_, err := q.db.ExecContext(ctx, insertSegment,
		arg.ID,
		arg.StreamID,
		arg.OutputConfigurationID,
		arg.Path,
		arg.RelativeTimestamp,
		arg.Timestamp,
	)
	return err
}

const insertStream = `-- name: InsertStream :exec
INSERT INTO streams (id, stream_title, start_time, end_time) VALUES($1, $2, $3, $4)
`

type InsertStreamParams struct {
	ID          string
	StreamTitle sql.NullString
	StartTime   sql.NullTime
	EndTime     sql.NullTime
}

func (q *Queries) InsertStream(ctx context.Context, arg InsertStreamParams) error {
	_, err := q.db.ExecContext(ctx, insertStream,
		arg.ID,
		arg.StreamTitle,
		arg.StartTime,
		arg.EndTime,
	)
	return err
}

const isDisplayNameAvailable = `-- name: IsDisplayNameAvailable :one
SELECT count(*) FROM users WHERE display_name = $1 AND authenticated_at is not null AND disabled_at is NULL
`

func (q *Queries) IsDisplayNameAvailable(ctx context.Context, displayName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, isDisplayNameAvailable, displayName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const isIPAddressBlocked = `-- name: IsIPAddressBlocked :one
SELECT count(*) FROM ip_bans WHERE ip_address = $1
`

func (q *Queries) IsIPAddressBlocked(ctx context.Context, ipAddress string) (int64, error) {
	row := q.db.QueryRowContext(ctx, isIPAddressBlocked, ipAddress)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const rejectFederationFollower = `-- name: RejectFederationFollower :exec
UPDATE ap_followers SET approved_at = null, disabled_at = $1 WHERE iri = $2
`

type RejectFederationFollowerParams struct {
	DisabledAt sql.NullTime
	Iri        string
}

func (q *Queries) RejectFederationFollower(ctx context.Context, arg RejectFederationFollowerParams) error {
	_, err := q.db.ExecContext(ctx, rejectFederationFollower, arg.DisabledAt, arg.Iri)
	return err
}

const removeFollowerByIRI = `-- name: RemoveFollowerByIRI :exec
DELETE FROM ap_followers WHERE iri = $1
`

func (q *Queries) RemoveFollowerByIRI(ctx context.Context, iri string) error {
	_, err := q.db.ExecContext(ctx, removeFollowerByIRI, iri)
	return err
}

const removeIPAddressBan = `-- name: RemoveIPAddressBan :exec
DELETE FROM ip_bans WHERE ip_address = $1
`

func (q *Queries) RemoveIPAddressBan(ctx context.Context, ipAddress string) error {
	_, err := q.db.ExecContext(ctx, removeIPAddressBan, ipAddress)
	return err
}

const removeNotificationDestinationForChannel = `-- name: RemoveNotificationDestinationForChannel :exec
DELETE FROM notifications WHERE channel = $1 AND destination = $2
`

type RemoveNotificationDestinationForChannelParams struct {
	Channel     string
	Destination string
}

func (q *Queries) RemoveNotificationDestinationForChannel(ctx context.Context, arg RemoveNotificationDestinationForChannelParams) error {
	_, err := q.db.ExecContext(ctx, removeNotificationDestinationForChannel, arg.Channel, arg.Destination)
	return err
}

const setAccessTokenToOwner = `-- name: SetAccessTokenToOwner :exec
UPDATE user_access_tokens SET user_id = $1 WHERE token = $2
`

type SetAccessTokenToOwnerParams struct {
	UserID string
	Token  string
}

func (q *Queries) SetAccessTokenToOwner(ctx context.Context, arg SetAccessTokenToOwnerParams) error {
	_, err := q.db.ExecContext(ctx, setAccessTokenToOwner, arg.UserID, arg.Token)
	return err
}

const setStreamEnded = `-- name: SetStreamEnded :exec
UPDATE streams SET end_time = $1 WHERE id = $2
`

type SetStreamEndedParams struct {
	EndTime sql.NullTime
	ID      string
}

func (q *Queries) SetStreamEnded(ctx context.Context, arg SetStreamEndedParams) error {
	_, err := q.db.ExecContext(ctx, setStreamEnded, arg.EndTime, arg.ID)
	return err
}

const setUserAsAuthenticated = `-- name: SetUserAsAuthenticated :exec
UPDATE users SET authenticated_at = CURRENT_TIMESTAMP WHERE id = $1
`

func (q *Queries) SetUserAsAuthenticated(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, setUserAsAuthenticated, id)
	return err
}

const updateFollowerByIRI = `-- name: UpdateFollowerByIRI :exec
UPDATE ap_followers SET inbox = $1, name = $2, username = $3, image = $4 WHERE iri = $5
`

type UpdateFollowerByIRIParams struct {
	Inbox    string
	Name     sql.NullString
	Username string
	Image    sql.NullString
	Iri      string
}

func (q *Queries) UpdateFollowerByIRI(ctx context.Context, arg UpdateFollowerByIRIParams) error {
	_, err := q.db.ExecContext(ctx, updateFollowerByIRI,
		arg.Inbox,
		arg.Name,
		arg.Username,
		arg.Image,
		arg.Iri,
	)
	return err
}
