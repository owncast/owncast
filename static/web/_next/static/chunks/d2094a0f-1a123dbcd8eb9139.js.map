{"version":3,"file":"static/chunks/d2094a0f-1a123dbcd8eb9139.js","mappings":"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","sources":["webpack://_N_E/./node_modules/slate-react/dist/index.es.js"],"sourcesContent":["import getDirection from 'direction';\nimport debounce from 'lodash/debounce';\nimport throttle from 'lodash/throttle';\nimport React, { useLayoutEffect, useEffect, useRef, createContext, useContext, useCallback, Component, useState, useReducer, useMemo } from 'react';\nimport scrollIntoView from 'scroll-into-view-if-needed';\nimport { Editor, Scrubber, Transforms, Range, Path, Node, Text as Text$1, Element as Element$1, Point } from 'slate';\nimport { isKeyHotkey } from 'is-hotkey';\nimport ReactDOM from 'react-dom';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n/**\r\n * An auto-incrementing identifier for keys.\r\n */\nvar n = 0;\n/**\r\n * A class that keeps track of a key string. We use a full class here because we\r\n * want to be able to use them as keys in `WeakMap` objects.\r\n */\n\nclass Key {\n  constructor() {\n    this.id = \"\".concat(n++);\n  }\n\n}\n\n/**\r\n * Two weak maps that allow us rebuild a path given a node. They are populated\r\n * at render time such that after a render occurs we can always backtrack.\r\n */\nvar NODE_TO_INDEX = new WeakMap();\nvar NODE_TO_PARENT = new WeakMap();\n/**\r\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\r\n * are used to resolve DOM event-related logic into Slate actions.\r\n */\n\nvar EDITOR_TO_WINDOW = new WeakMap();\nvar EDITOR_TO_ELEMENT = new WeakMap();\nvar EDITOR_TO_PLACEHOLDER_ELEMENT = new WeakMap();\nvar ELEMENT_TO_NODE = new WeakMap();\nvar NODE_TO_ELEMENT = new WeakMap();\nvar NODE_TO_KEY = new WeakMap();\nvar EDITOR_TO_KEY_TO_ELEMENT = new WeakMap();\nvar EDITOR_TO_STYLE_ELEMENT = new WeakMap();\n/**\r\n * Weak maps for storing editor-related state.\r\n */\n\nvar IS_READ_ONLY = new WeakMap();\nvar IS_FOCUSED = new WeakMap();\nvar IS_COMPOSING = new WeakMap();\nvar EDITOR_TO_USER_SELECTION = new WeakMap();\n/**\r\n * Weak map for associating the context `onChange` context with the plugin.\r\n */\n\nvar EDITOR_TO_ON_CHANGE = new WeakMap();\n/**\r\n * Weak maps for saving pending state on composition stage.\r\n */\n\nvar EDITOR_TO_SCHEDULE_FLUSH = new WeakMap();\nvar EDITOR_TO_PENDING_INSERTION_MARKS = new WeakMap();\nvar EDITOR_TO_USER_MARKS = new WeakMap();\n/**\r\n * Android input handling specific weak-maps\r\n */\n\nvar EDITOR_TO_PENDING_DIFFS = new WeakMap();\nvar EDITOR_TO_PENDING_ACTION = new WeakMap();\nvar EDITOR_TO_PENDING_SELECTION = new WeakMap();\nvar EDITOR_TO_FORCE_RENDER = new WeakMap();\n/**\r\n * Symbols.\r\n */\n\nvar PLACEHOLDER_SYMBOL = Symbol('placeholder');\nvar MARK_PLACEHOLDER_SYMBOL = Symbol('mark-placeholder');\n\n/**\r\n * Types.\r\n */\nvar DOMText = globalThis.Text;\n/**\r\n * Returns the host window of a DOM node\r\n */\n\nvar getDefaultView = value => {\n  return value && value.ownerDocument && value.ownerDocument.defaultView || null;\n};\n/**\r\n * Check if a DOM node is a comment node.\r\n */\n\nvar isDOMComment = value => {\n  return isDOMNode(value) && value.nodeType === 8;\n};\n/**\r\n * Check if a DOM node is an element node.\r\n */\n\nvar isDOMElement = value => {\n  return isDOMNode(value) && value.nodeType === 1;\n};\n/**\r\n * Check if a value is a DOM node.\r\n */\n\nvar isDOMNode = value => {\n  var window = getDefaultView(value);\n  return !!window && value instanceof window.Node;\n};\n/**\r\n * Check if a value is a DOM selection.\r\n */\n\nvar isDOMSelection = value => {\n  var window = value && value.anchorNode && getDefaultView(value.anchorNode);\n  return !!window && value instanceof window.Selection;\n};\n/**\r\n * Check if a DOM node is an element node.\r\n */\n\nvar isDOMText = value => {\n  return isDOMNode(value) && value.nodeType === 3;\n};\n/**\r\n * Checks whether a paste event is a plaintext-only event.\r\n */\n\nvar isPlainTextOnlyPaste = event => {\n  return event.clipboardData && event.clipboardData.getData('text/plain') !== '' && event.clipboardData.types.length === 1;\n};\n/**\r\n * Normalize a DOM point so that it always refers to a text node.\r\n */\n\nvar normalizeDOMPoint = domPoint => {\n  var [node, offset] = domPoint; // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n\n  if (isDOMElement(node) && node.childNodes.length) {\n    var isLast = offset === node.childNodes.length;\n    var index = isLast ? offset - 1 : offset;\n    [node, index] = getEditableChildAndIndex(node, index, isLast ? 'backward' : 'forward'); // If the editable child found is in front of input offset, we instead seek to its end\n\n    isLast = index < offset; // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n\n    while (isDOMElement(node) && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild(node, i, isLast ? 'backward' : 'forward');\n    } // Determine the new offset inside the text node.\n\n\n    offset = isLast && node.textContent != null ? node.textContent.length : 0;\n  } // Return the node and offset.\n\n\n  return [node, offset];\n};\n/**\r\n * Determines wether the active element is nested within a shadowRoot\r\n */\n\nvar hasShadowRoot = () => {\n  return !!(window.document.activeElement && window.document.activeElement.shadowRoot);\n};\n/**\r\n * Get the nearest editable child and index at `index` in a `parent`, preferring\r\n * `direction`.\r\n */\n\nvar getEditableChildAndIndex = (parent, index, direction) => {\n  var {\n    childNodes\n  } = parent;\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false; // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n\n  while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute('contenteditable') === 'false') {\n    if (triedForward && triedBackward) {\n      break;\n    }\n\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n\n    child = childNodes[i];\n    index = i;\n    i += direction === 'forward' ? 1 : -1;\n  }\n\n  return [child, index];\n};\n/**\r\n * Get the nearest editable child at `index` in a `parent`, preferring\r\n * `direction`.\r\n */\n\nvar getEditableChild = (parent, index, direction) => {\n  var [child] = getEditableChildAndIndex(parent, index, direction);\n  return child;\n};\n/**\r\n * Get a plaintext representation of the content of a node, accounting for block\r\n * elements which get a newline appended.\r\n *\r\n * The domNode must be attached to the DOM.\r\n */\n\nvar getPlainText = domNode => {\n  var text = '';\n\n  if (isDOMText(domNode) && domNode.nodeValue) {\n    return domNode.nodeValue;\n  }\n\n  if (isDOMElement(domNode)) {\n    for (var childNode of Array.from(domNode.childNodes)) {\n      text += getPlainText(childNode);\n    }\n\n    var display = getComputedStyle(domNode).getPropertyValue('display');\n\n    if (display === 'block' || display === 'list' || domNode.tagName === 'BR') {\n      text += '\\n';\n    }\n  }\n\n  return text;\n};\n/**\r\n * Get x-slate-fragment attribute from data-slate-fragment\r\n */\n\nvar catchSlateFragment = /data-slate-fragment=\"(.+?)\"/m;\nvar getSlateFragmentAttribute = dataTransfer => {\n  var htmlData = dataTransfer.getData('text/html');\n  var [, fragment] = htmlData.match(catchSlateFragment) || [];\n  return fragment;\n};\n/**\r\n * Check whether a mutation originates from a editable element inside the editor.\r\n */\n\nvar isTrackedMutation = (editor, mutation, batch) => {\n  var {\n    target\n  } = mutation;\n\n  if (isDOMElement(target) && target.matches('[contentEditable=\"false\"]')) {\n    return false;\n  }\n\n  var {\n    document\n  } = ReactEditor.getWindow(editor);\n\n  if (document.contains(target)) {\n    return ReactEditor.hasDOMNode(editor, target, {\n      editable: true\n    });\n  }\n\n  var parentMutation = batch.find(_ref => {\n    var {\n      addedNodes,\n      removedNodes\n    } = _ref;\n\n    for (var node of addedNodes) {\n      if (node === target || node.contains(target)) {\n        return true;\n      }\n    }\n\n    for (var _node of removedNodes) {\n      if (_node === target || _node.contains(target)) {\n        return true;\n      }\n    }\n  });\n\n  if (!parentMutation || parentMutation === mutation) {\n    return false;\n  } // Target add/remove is tracked. Track the mutation if we track the parent mutation.\n\n\n  return isTrackedMutation(editor, parentMutation, batch);\n};\n\nvar IS_REACT_VERSION_17_OR_ABOVE = parseInt(React.version.split('.')[0], 10) >= 17;\nvar IS_IOS = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nvar IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent);\nvar IS_ANDROID = typeof navigator !== 'undefined' && /Android/.test(navigator.userAgent);\nvar IS_FIREFOX = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nvar IS_SAFARI = typeof navigator !== 'undefined' && /Version\\/[\\d\\.]+.*Safari/.test(navigator.userAgent); // \"modern\" Edge was released at 79.x\n\nvar IS_EDGE_LEGACY = typeof navigator !== 'undefined' && /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])(?:\\.)/i.test(navigator.userAgent);\nvar IS_CHROME = typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent); // Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\n\nvar IS_CHROME_LEGACY = typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])(?:\\.)/i.test(navigator.userAgent); // Firefox did not support `beforeInput` until `v87`.\n\nvar IS_FIREFOX_LEGACY = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])(?:\\.)).*/i.test(navigator.userAgent); // qq browser\n\nvar IS_QQBROWSER = typeof navigator !== 'undefined' && /.*QQBrowser/.test(navigator.userAgent); // UC mobile browser\n\nvar IS_UC_MOBILE = typeof navigator !== 'undefined' && /.*UCBrowser/.test(navigator.userAgent); // Wechat browser\n\nvar IS_WECHATBROWSER = typeof navigator !== 'undefined' && /.*Wechat/.test(navigator.userAgent); // Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\n\nvar CAN_USE_DOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined'); // COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event\n// Chrome Legacy doesn't support `beforeinput` correctly\n\nvar HAS_BEFORE_INPUT_SUPPORT = !IS_CHROME_LEGACY && !IS_EDGE_LEGACY && // globalThis is undefined in older browsers\ntypeof globalThis !== 'undefined' && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.\ntypeof globalThis.InputEvent.prototype.getTargetRanges === 'function';\n\nvar ReactEditor = {\n  /**\r\n   * Check if the user is currently composing inside the editor.\r\n   */\n  isComposing(editor) {\n    return !!IS_COMPOSING.get(editor);\n  },\n\n  /**\r\n   * Return the host window of the current editor.\r\n   */\n  getWindow(editor) {\n    var window = EDITOR_TO_WINDOW.get(editor);\n\n    if (!window) {\n      throw new Error('Unable to find a host window element for this editor');\n    }\n\n    return window;\n  },\n\n  /**\r\n   * Find a key for a Slate node.\r\n   */\n  findKey(editor, node) {\n    var key = NODE_TO_KEY.get(node);\n\n    if (!key) {\n      key = new Key();\n      NODE_TO_KEY.set(node, key);\n    }\n\n    return key;\n  },\n\n  /**\r\n   * Find the path of Slate node.\r\n   */\n  findPath(editor, node) {\n    var path = [];\n    var child = node;\n\n    while (true) {\n      var parent = NODE_TO_PARENT.get(child);\n\n      if (parent == null) {\n        if (Editor.isEditor(child)) {\n          return path;\n        } else {\n          break;\n        }\n      }\n\n      var i = NODE_TO_INDEX.get(child);\n\n      if (i == null) {\n        break;\n      }\n\n      path.unshift(i);\n      child = parent;\n    }\n\n    throw new Error(\"Unable to find the path for Slate node: \".concat(Scrubber.stringify(node)));\n  },\n\n  /**\r\n   * Find the DOM node that implements DocumentOrShadowRoot for the editor.\r\n   */\n  findDocumentOrShadowRoot(editor) {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = el.getRootNode();\n\n    if ((root instanceof Document || root instanceof ShadowRoot) && root.getSelection != null) {\n      return root;\n    }\n\n    return el.ownerDocument;\n  },\n\n  /**\r\n   * Check if the editor is focused.\r\n   */\n  isFocused(editor) {\n    return !!IS_FOCUSED.get(editor);\n  },\n\n  /**\r\n   * Check if the editor is in read-only mode.\r\n   */\n  isReadOnly(editor) {\n    return !!IS_READ_ONLY.get(editor);\n  },\n\n  /**\r\n   * Blur the editor.\r\n   */\n  blur(editor) {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    IS_FOCUSED.set(editor, false);\n\n    if (root.activeElement === el) {\n      el.blur();\n    }\n  },\n\n  /**\r\n   * Focus the editor.\r\n   */\n  focus(editor) {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    IS_FOCUSED.set(editor, true);\n\n    if (root.activeElement !== el) {\n      el.focus({\n        preventScroll: true\n      });\n    }\n  },\n\n  /**\r\n   * Deselect the editor.\r\n   */\n  deselect(editor) {\n    var {\n      selection\n    } = editor;\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = root.getSelection();\n\n    if (domSelection && domSelection.rangeCount > 0) {\n      domSelection.removeAllRanges();\n    }\n\n    if (selection) {\n      Transforms.deselect(editor);\n    }\n  },\n\n  /**\r\n   * Check if a DOM node is within the editor.\r\n   */\n  hasDOMNode(editor, target) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      editable = false\n    } = options;\n    var editorEl = ReactEditor.toDOMNode(editor, editor);\n    var targetEl; // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n    // target is originating from an internal \"restricted\" element (e.g. a\n    // stepper arrow on a number input). (2018/05/04)\n    // https://github.com/ianstormtaylor/slate/issues/1819\n\n    try {\n      targetEl = isDOMElement(target) ? target : target.parentElement;\n    } catch (err) {\n      if (!err.message.includes('Permission denied to access property \"nodeType\"')) {\n        throw err;\n      }\n    }\n\n    if (!targetEl) {\n      return false;\n    }\n\n    return targetEl.closest(\"[data-slate-editor]\") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === 'boolean' && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined\n    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable=\"false\"(readOnly)\n    targetEl.closest('[contenteditable=\"false\"]') === editorEl || !!targetEl.getAttribute('data-slate-zero-width'));\n  },\n\n  /**\r\n   * Insert data from a `DataTransfer` into the editor.\r\n   */\n  insertData(editor, data) {\n    editor.insertData(data);\n  },\n\n  /**\r\n   * Insert fragment data from a `DataTransfer` into the editor.\r\n   */\n  insertFragmentData(editor, data) {\n    return editor.insertFragmentData(data);\n  },\n\n  /**\r\n   * Insert text data from a `DataTransfer` into the editor.\r\n   */\n  insertTextData(editor, data) {\n    return editor.insertTextData(data);\n  },\n\n  /**\r\n   * Sets data from the currently selected fragment on a `DataTransfer`.\r\n   */\n  setFragmentData(editor, data, originEvent) {\n    editor.setFragmentData(data, originEvent);\n  },\n\n  /**\r\n   * Find the native DOM element from a Slate node.\r\n   */\n  toDOMNode(editor, node) {\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n    var domNode = Editor.isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(ReactEditor.findKey(editor, node));\n\n    if (!domNode) {\n      throw new Error(\"Cannot resolve a DOM node from Slate node: \".concat(Scrubber.stringify(node)));\n    }\n\n    return domNode;\n  },\n\n  /**\r\n   * Find a native DOM selection point from a Slate point.\r\n   */\n  toDOMPoint(editor, point) {\n    var [node] = Editor.node(editor, point.path);\n    var el = ReactEditor.toDOMNode(editor, node);\n    var domPoint; // If we're inside a void node, force the offset to 0, otherwise the zero\n    // width spacing character will result in an incorrect offset of 1\n\n    if (Editor.void(editor, {\n      at: point\n    })) {\n      point = {\n        path: point.path,\n        offset: 0\n      };\n    } // For each leaf, we need to isolate its content, which means filtering\n    // to its direct text and zero-width spans. (We have to filter out any\n    // other siblings that may have been rendered alongside them.)\n\n\n    var selector = \"[data-slate-string], [data-slate-zero-width]\";\n    var texts = Array.from(el.querySelectorAll(selector));\n    var start = 0;\n\n    for (var i = 0; i < texts.length; i++) {\n      var text = texts[i];\n      var domNode = text.childNodes[0];\n\n      if (domNode == null || domNode.textContent == null) {\n        continue;\n      }\n\n      var {\n        length\n      } = domNode.textContent;\n      var attr = text.getAttribute('data-slate-length');\n      var trueLength = attr == null ? length : parseInt(attr, 10);\n      var end = start + trueLength; // Prefer putting the selection inside the mark placeholder to ensure\n      // composed text is displayed with the correct marks.\n\n      var nextText = texts[i + 1];\n\n      if (point.offset === end && nextText !== null && nextText !== void 0 && nextText.hasAttribute('data-slate-mark-placeholder')) {\n        var _nextText$textContent;\n\n        var domText = nextText.childNodes[0];\n        domPoint = [// COMPAT: If we don't explicity set the dom point to be on the actual\n        // dom text element, chrome will put the selection behind the actual dom\n        // text element, causing domRange.getBoundingClientRect() calls on a collapsed\n        // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)\n        // which will cause issues when scrolling to it.\n        domText instanceof DOMText ? domText : nextText, (_nextText$textContent = nextText.textContent) !== null && _nextText$textContent !== void 0 && _nextText$textContent.startsWith('\\uFEFF') ? 1 : 0];\n        break;\n      }\n\n      if (point.offset <= end) {\n        var offset = Math.min(length, Math.max(0, point.offset - start));\n        domPoint = [domNode, offset];\n        break;\n      }\n\n      start = end;\n    }\n\n    if (!domPoint) {\n      throw new Error(\"Cannot resolve a DOM point from Slate point: \".concat(Scrubber.stringify(point)));\n    }\n\n    return domPoint;\n  },\n\n  /**\r\n   * Find a native DOM range from a Slate `range`.\r\n   *\r\n   * Notice: the returned range will always be ordinal regardless of the direction of Slate `range` due to DOM API limit.\r\n   *\r\n   * there is no way to create a reverse DOM Range using Range.setStart/setEnd\r\n   * according to https://dom.spec.whatwg.org/#concept-range-bp-set.\r\n   */\n  toDOMRange(editor, range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    var isBackward = Range.isBackward(range);\n    var domAnchor = ReactEditor.toDOMPoint(editor, anchor);\n    var domFocus = Range.isCollapsed(range) ? domAnchor : ReactEditor.toDOMPoint(editor, focus);\n    var window = ReactEditor.getWindow(editor);\n    var domRange = window.document.createRange();\n    var [startNode, startOffset] = isBackward ? domFocus : domAnchor;\n    var [endNode, endOffset] = isBackward ? domAnchor : domFocus; // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n    // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n    // adjust the offset accordingly.\n\n    var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;\n    var isStartAtZeroWidth = !!startEl.getAttribute('data-slate-zero-width');\n    var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;\n    var isEndAtZeroWidth = !!endEl.getAttribute('data-slate-zero-width');\n    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);\n    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);\n    return domRange;\n  },\n\n  /**\r\n   * Find a Slate node from a native DOM `element`.\r\n   */\n  toSlateNode(editor, domNode) {\n    var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;\n\n    if (domEl && !domEl.hasAttribute('data-slate-node')) {\n      domEl = domEl.closest(\"[data-slate-node]\");\n    }\n\n    var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;\n\n    if (!node) {\n      throw new Error(\"Cannot resolve a Slate node from DOM node: \".concat(domEl));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Get the target range from a DOM `event`.\r\n   */\n  findEventRange(editor, event) {\n    if ('nativeEvent' in event) {\n      event = event.nativeEvent;\n    }\n\n    var {\n      clientX: x,\n      clientY: y,\n      target\n    } = event;\n\n    if (x == null || y == null) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    }\n\n    var node = ReactEditor.toSlateNode(editor, event.target);\n    var path = ReactEditor.findPath(editor, node); // If the drop target is inside a void node, move it into either the\n    // next or previous node, depending on which side the `x` and `y`\n    // coordinates are closest to.\n\n    if (Editor.isVoid(editor, node)) {\n      var rect = target.getBoundingClientRect();\n      var isPrev = editor.isInline(node) ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n      var edge = Editor.point(editor, path, {\n        edge: isPrev ? 'start' : 'end'\n      });\n      var point = isPrev ? Editor.before(editor, edge) : Editor.after(editor, edge);\n\n      if (point) {\n        var _range = Editor.range(editor, point);\n\n        return _range;\n      }\n    } // Else resolve a range from the caret position where the drop occured.\n\n\n    var domRange;\n    var {\n      document\n    } = ReactEditor.getWindow(editor); // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n\n    if (document.caretRangeFromPoint) {\n      domRange = document.caretRangeFromPoint(x, y);\n    } else {\n      var position = document.caretPositionFromPoint(x, y);\n\n      if (position) {\n        domRange = document.createRange();\n        domRange.setStart(position.offsetNode, position.offset);\n        domRange.setEnd(position.offsetNode, position.offset);\n      }\n    }\n\n    if (!domRange) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    } // Resolve a Slate range from the DOM range.\n\n\n    var range = ReactEditor.toSlateRange(editor, domRange, {\n      exactMatch: false,\n      suppressThrow: false\n    });\n    return range;\n  },\n\n  /**\r\n   * Find a Slate point from a DOM selection's `domNode` and `domOffset`.\r\n   */\n  toSlatePoint(editor, domPoint, options) {\n    var {\n      exactMatch,\n      suppressThrow\n    } = options;\n    var [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint);\n    var parentNode = nearestNode.parentNode;\n    var textNode = null;\n    var offset = 0;\n\n    if (parentNode) {\n      var _domNode$textContent, _domNode$textContent2;\n\n      var editorEl = ReactEditor.toDOMNode(editor, editor);\n      var potentialVoidNode = parentNode.closest('[data-slate-void=\"true\"]'); // Need to ensure that the closest void node is actually a void node\n      // within this editor, and not a void node within some parent editor. This can happen\n      // if this editor is within a void node of another editor (\"nested editors\", like in\n      // the \"Editable Voids\" example on the docs site).\n\n      var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;\n      var leafNode = parentNode.closest('[data-slate-leaf]');\n      var domNode = null; // Calculate how far into the text node the `nearestNode` is, so that we\n      // can determine what the offset relative to the text node is.\n\n      if (leafNode) {\n        textNode = leafNode.closest('[data-slate-node=\"text\"]');\n\n        if (textNode) {\n          var window = ReactEditor.getWindow(editor);\n          var range = window.document.createRange();\n          range.setStart(textNode, 0);\n          range.setEnd(nearestNode, nearestOffset);\n          var contents = range.cloneContents();\n          var removals = [...Array.prototype.slice.call(contents.querySelectorAll('[data-slate-zero-width]')), ...Array.prototype.slice.call(contents.querySelectorAll('[contenteditable=false]'))];\n          removals.forEach(el => {\n            // COMPAT: While composing at the start of a text node, some keyboards put\n            // the text content inside the zero width space.\n            if (IS_ANDROID && !exactMatch && el.hasAttribute('data-slate-zero-width') && el.textContent.length > 0 && el.textContext !== '\\uFEFF') {\n              if (el.textContent.startsWith('\\uFEFF')) {\n                el.textContent = el.textContent.slice(1);\n              }\n\n              return;\n            }\n\n            el.parentNode.removeChild(el);\n          }); // COMPAT: Edge has a bug where Range.prototype.toString() will\n          // convert \\n into \\r\\n. The bug causes a loop when slate-react\n          // attempts to reposition its cursor to match the native position. Use\n          // textContent.length instead.\n          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n\n          offset = contents.textContent.length;\n          domNode = textNode;\n        }\n      } else if (voidNode) {\n        // For void nodes, the element with the offset key will be a cousin, not an\n        // ancestor, so find it by going down from the nearest void parent and taking the\n        // first one that isn't inside a nested editor.\n        var leafNodes = voidNode.querySelectorAll('[data-slate-leaf]');\n\n        for (var index = 0; index < leafNodes.length; index++) {\n          var current = leafNodes[index];\n\n          if (ReactEditor.hasDOMNode(editor, current)) {\n            leafNode = current;\n            break;\n          }\n        } // COMPAT: In read-only editors the leaf is not rendered.\n\n\n        if (!leafNode) {\n          offset = 1;\n        } else {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]');\n          domNode = leafNode;\n          offset = domNode.textContent.length;\n          domNode.querySelectorAll('[data-slate-zero-width]').forEach(el => {\n            offset -= el.textContent.length;\n          });\n        }\n      }\n\n      if (domNode && offset === domNode.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,\n      // and we don't add it for line-breaks.\n      IS_ANDROID && domNode.getAttribute('data-slate-zero-width') === 'z' && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.startsWith('\\uFEFF') && (parentNode.hasAttribute('data-slate-zero-width') || IS_FIREFOX && (_domNode$textContent2 = domNode.textContent) !== null && _domNode$textContent2 !== void 0 && _domNode$textContent2.endsWith('\\n\\n'))) {\n        offset--;\n      }\n    }\n\n    if (IS_ANDROID && !textNode && !exactMatch) {\n      var node = parentNode.hasAttribute('data-slate-node') ? parentNode : parentNode.closest('[data-slate-node]');\n\n      if (node && ReactEditor.hasDOMNode(editor, node, {\n        editable: true\n      })) {\n        var _slateNode = ReactEditor.toSlateNode(editor, node);\n\n        var {\n          path: _path,\n          offset: _offset\n        } = Editor.start(editor, ReactEditor.findPath(editor, _slateNode));\n\n        if (!node.querySelector('[data-slate-leaf]')) {\n          _offset = nearestOffset;\n        }\n\n        return {\n          path: _path,\n          offset: _offset\n        };\n      }\n    }\n\n    if (!textNode) {\n      if (suppressThrow) {\n        return null;\n      }\n\n      throw new Error(\"Cannot resolve a Slate point from DOM point: \".concat(domPoint));\n    } // COMPAT: If someone is clicking from one Slate editor into another,\n    // the select event fires twice, once for the old editor's `element`\n    // first, and then afterwards for the correct `element`. (2017/03/03)\n\n\n    var slateNode = ReactEditor.toSlateNode(editor, textNode);\n    var path = ReactEditor.findPath(editor, slateNode);\n    return {\n      path,\n      offset\n    };\n  },\n\n  /**\r\n   * Find a Slate range from a DOM range or selection.\r\n   */\n  toSlateRange(editor, domRange, options) {\n    var {\n      exactMatch,\n      suppressThrow\n    } = options;\n    var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;\n    var anchorNode;\n    var anchorOffset;\n    var focusNode;\n    var focusOffset;\n    var isCollapsed;\n\n    if (el) {\n      if (isDOMSelection(domRange)) {\n        anchorNode = domRange.anchorNode;\n        anchorOffset = domRange.anchorOffset;\n        focusNode = domRange.focusNode;\n        focusOffset = domRange.focusOffset; // COMPAT: There's a bug in chrome that always returns `true` for\n        // `isCollapsed` for a Selection that comes from a ShadowRoot.\n        // (2020/08/08)\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n\n        if (IS_CHROME && hasShadowRoot()) {\n          isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;\n        } else {\n          isCollapsed = domRange.isCollapsed;\n        }\n      } else {\n        anchorNode = domRange.startContainer;\n        anchorOffset = domRange.startOffset;\n        focusNode = domRange.endContainer;\n        focusOffset = domRange.endOffset;\n        isCollapsed = domRange.collapsed;\n      }\n    }\n\n    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {\n      throw new Error(\"Cannot resolve a Slate range from DOM range: \".concat(domRange));\n    }\n\n    var anchor = ReactEditor.toSlatePoint(editor, [anchorNode, anchorOffset], {\n      exactMatch,\n      suppressThrow\n    });\n\n    if (!anchor) {\n      return null;\n    }\n\n    var focus = isCollapsed ? anchor : ReactEditor.toSlatePoint(editor, [focusNode, focusOffset], {\n      exactMatch,\n      suppressThrow\n    });\n\n    if (!focus) {\n      return null;\n    }\n\n    var range = {\n      anchor: anchor,\n      focus: focus\n    }; // if the selection is a hanging range that ends in a void\n    // and the DOM focus is an Element\n    // (meaning that the selection ends before the element)\n    // unhang the range to avoid mistakenly including the void\n\n    if (Range.isExpanded(range) && Range.isForward(range) && isDOMElement(focusNode) && Editor.void(editor, {\n      at: range.focus,\n      mode: 'highest'\n    })) {\n      range = Editor.unhangRange(editor, range, {\n        voids: true\n      });\n    }\n\n    return range;\n  },\n\n  hasRange(editor, range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Editor.hasPath(editor, anchor.path) && Editor.hasPath(editor, focus.path);\n  },\n\n  /**\r\n   * Check if the target is in the editor.\r\n   */\n  hasTarget(editor, target) {\n    return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target);\n  },\n\n  /**\r\n   * Check if the target is editable and in the editor.\r\n   */\n  hasEditableTarget(editor, target) {\n    return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target, {\n      editable: true\n    });\n  },\n\n  /**\r\n   * Check if the target can be selectable\r\n   */\n  hasSelectableTarget(editor, target) {\n    return ReactEditor.hasEditableTarget(editor, target) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, target);\n  },\n\n  /**\r\n   * Check if the target is inside void and in an non-readonly editor.\r\n   */\n  isTargetInsideNonReadonlyVoid(editor, target) {\n    if (IS_READ_ONLY.get(editor)) return false;\n    var slateNode = ReactEditor.hasTarget(editor, target) && ReactEditor.toSlateNode(editor, target);\n    return Editor.isVoid(editor, slateNode);\n  },\n\n  /**\r\n   * Experimental and android specific: Flush all pending diffs and cancel composition at the next possible time.\r\n   */\n  androidScheduleFlush(editor) {\n    var _EDITOR_TO_SCHEDULE_F;\n\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(editor)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();\n  },\n\n  /**\r\n   * Experimental and android specific: Get pending diffs\r\n   */\n  androidPendingDiffs(editor) {\n    return EDITOR_TO_PENDING_DIFFS.get(editor);\n  }\n\n};\n\n/**\r\n * Prevent warning on SSR by falling back to useEffect when DOM isn't available\r\n */\n\nvar useIsomorphicLayoutEffect = CAN_USE_DOM ? useLayoutEffect : useEffect;\n\nvar _excluded$3 = [\"anchor\", \"focus\"],\n    _excluded2$1 = [\"anchor\", \"focus\"];\nvar shallowCompare = (obj1, obj2) => Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every(key => obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);\n/**\r\n * Check if a list of decorator ranges are equal to another.\r\n *\r\n * PERF: this requires the two lists to also have the ranges inside them in the\r\n * same order, but this is an okay constraint for us since decorations are\r\n * kept in order, and the odd case where they aren't is okay to re-render for.\r\n */\n\nvar isDecoratorRangeListEqual = (list, another) => {\n  if (list.length !== another.length) {\n    return false;\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i];\n\n    var rangeOwnProps = _objectWithoutProperties(range, _excluded$3);\n\n    var otherOwnProps = _objectWithoutProperties(other, _excluded2$1);\n\n    if (!Range.equals(range, other) || range[PLACEHOLDER_SYMBOL] !== other[PLACEHOLDER_SYMBOL] || !shallowCompare(rangeOwnProps, otherOwnProps)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\r\n * Leaf content strings.\r\n */\n\nvar String = props => {\n  var {\n    isLast,\n    leaf,\n    parent,\n    text\n  } = props;\n  var editor = useSlateStatic();\n  var path = ReactEditor.findPath(editor, text);\n  var parentPath = Path.parent(path);\n  var isMarkPlaceholder = leaf[MARK_PLACEHOLDER_SYMBOL] === true; // COMPAT: Render text inside void nodes with a zero-width space.\n  // So the node can contain selection but the text is not visible.\n\n  if (editor.isVoid(parent)) {\n    return /*#__PURE__*/React.createElement(ZeroWidthString, {\n      length: Node.string(parent).length\n    });\n  } // COMPAT: If this is the last text node in an empty block, render a zero-\n  // width space that will convert into a line break when copying and pasting\n  // to support expected plain text.\n\n\n  if (leaf.text === '' && parent.children[parent.children.length - 1] === text && !editor.isInline(parent) && Editor.string(editor, parentPath) === '') {\n    return /*#__PURE__*/React.createElement(ZeroWidthString, {\n      isLineBreak: true,\n      isMarkPlaceholder: isMarkPlaceholder\n    });\n  } // COMPAT: If the text is empty, it's because it's on the edge of an inline\n  // node, so we render a zero-width space so that the selection can be\n  // inserted next to it still.\n\n\n  if (leaf.text === '') {\n    return /*#__PURE__*/React.createElement(ZeroWidthString, {\n      isMarkPlaceholder: isMarkPlaceholder\n    });\n  } // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n  // so we need to add an extra trailing new lines to prevent that.\n\n\n  if (isLast && leaf.text.slice(-1) === '\\n') {\n    return /*#__PURE__*/React.createElement(TextString, {\n      isTrailing: true,\n      text: leaf.text\n    });\n  }\n\n  return /*#__PURE__*/React.createElement(TextString, {\n    text: leaf.text\n  });\n};\n/**\r\n * Leaf strings with text in them.\r\n */\n\n\nvar TextString = props => {\n  var {\n    text,\n    isTrailing = false\n  } = props;\n  var ref = useRef(null);\n\n  var getTextContent = () => {\n    return \"\".concat(text !== null && text !== void 0 ? text : '').concat(isTrailing ? '\\n' : '');\n  }; // This is the actual text rendering boundary where we interface with the DOM\n  // The text is not rendered as part of the virtual DOM, as since we handle basic character insertions natively,\n  // updating the DOM is not a one way dataflow anymore. What we need here is not reconciliation and diffing\n  // with previous version of the virtual DOM, but rather diffing with the actual DOM element, and replace the DOM <span> content\n  // exactly if and only if its current content does not match our current virtual DOM.\n  // Otherwise the DOM TextNode would always be replaced by React as the user types, which interferes with native text features,\n  // eg makes native spellcheck opt out from checking the text node.\n  // useLayoutEffect: updating our span before browser paint\n\n\n  useIsomorphicLayoutEffect(() => {\n    // null coalescing text to make sure we're not outputing \"null\" as a string in the extreme case it is nullish at runtime\n    var textWithTrailing = getTextContent();\n\n    if (ref.current && ref.current.textContent !== textWithTrailing) {\n      ref.current.textContent = textWithTrailing;\n    } // intentionally not specifying dependencies, so that this effect runs on every render\n    // as this effectively replaces \"specifying the text in the virtual DOM under the <span> below\" on each render\n\n  }); // Render text content immediately if it's the first-time render\n  // Ensure that text content is rendered on server-side rendering\n\n  if (!ref.current) {\n    return /*#__PURE__*/React.createElement(\"span\", {\n      \"data-slate-string\": true,\n      ref: ref\n    }, getTextContent());\n  } // the span is intentionally same on every render in virtual DOM, actual rendering happens in the layout effect above\n\n\n  return /*#__PURE__*/React.createElement(\"span\", {\n    \"data-slate-string\": true,\n    ref: ref\n  });\n};\n/**\r\n * Leaf strings without text, render as zero-width strings.\r\n */\n\n\nvar ZeroWidthString = props => {\n  var {\n    length = 0,\n    isLineBreak = false,\n    isMarkPlaceholder = false\n  } = props;\n  var attributes = {\n    'data-slate-zero-width': isLineBreak ? 'n' : 'z',\n    'data-slate-length': length\n  };\n\n  if (isMarkPlaceholder) {\n    attributes['data-slate-mark-placeholder'] = true;\n  }\n\n  return /*#__PURE__*/React.createElement(\"span\", Object.assign({}, attributes), !IS_ANDROID || !isLineBreak ? '\\uFEFF' : null, isLineBreak ? /*#__PURE__*/React.createElement(\"br\", null) : null);\n};\n\n/**\r\n * A React context for sharing the editor object.\r\n */\n\nvar EditorContext = /*#__PURE__*/createContext(null);\n/**\r\n * Get the current editor object from the React context.\r\n */\n\nvar useSlateStatic = () => {\n  var editor = useContext(EditorContext);\n\n  if (!editor) {\n    throw new Error(\"The `useSlateStatic` hook must be used inside the <Slate> component's context.\");\n  }\n\n  return editor;\n};\n\n/**\r\n * Individual leaves in a text node with unique formatting.\r\n */\n\nvar Leaf = props => {\n  var {\n    leaf,\n    isLast,\n    text,\n    parent,\n    renderPlaceholder,\n    renderLeaf = props => /*#__PURE__*/React.createElement(DefaultLeaf, Object.assign({}, props))\n  } = props;\n  var placeholderRef = useRef(null);\n  var editor = useSlateStatic();\n  var placeholderResizeObserver = useRef(null);\n  useEffect(() => {\n    return () => {\n      if (placeholderResizeObserver.current) {\n        placeholderResizeObserver.current.disconnect();\n      }\n    };\n  }, []);\n  useEffect(() => {\n    var placeholderEl = placeholderRef === null || placeholderRef === void 0 ? void 0 : placeholderRef.current;\n\n    if (placeholderEl) {\n      EDITOR_TO_PLACEHOLDER_ELEMENT.set(editor, placeholderEl);\n    } else {\n      EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);\n    }\n\n    if (placeholderResizeObserver.current) {\n      // Update existing observer.\n      placeholderResizeObserver.current.disconnect();\n      if (placeholderEl) placeholderResizeObserver.current.observe(placeholderEl);\n    } else if (placeholderEl) {\n      // Create a new observer and observe the placeholder element.\n      placeholderResizeObserver.current = new ResizeObserver(_ref => {\n        var [{\n          target\n        }] = _ref;\n        var styleElement = EDITOR_TO_STYLE_ELEMENT.get(editor);\n\n        if (styleElement) {\n          // Make the min-height the height of the placeholder.\n          var minHeight = \"\".concat(target.clientHeight, \"px\");\n          styleElement.innerHTML = \":where([data-slate-editor-id=\\\"\".concat(editor.id, \"\\\"]) { min-height: \").concat(minHeight, \"; }\");\n        }\n      });\n      placeholderResizeObserver.current.observe(placeholderEl);\n    }\n\n    if (!placeholderEl) {\n      // No placeholder element, so no need for a resize observer.\n      var styleElement = EDITOR_TO_STYLE_ELEMENT.get(editor);\n\n      if (styleElement) {\n        // No min-height if there is no placeholder.\n        styleElement.innerHTML = '';\n      }\n    }\n\n    return () => {\n      EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);\n    };\n  }, [placeholderRef, leaf]);\n  var children = /*#__PURE__*/React.createElement(String, {\n    isLast: isLast,\n    leaf: leaf,\n    parent: parent,\n    text: text\n  });\n\n  if (leaf[PLACEHOLDER_SYMBOL]) {\n    var placeholderProps = {\n      children: leaf.placeholder,\n      attributes: {\n        'data-slate-placeholder': true,\n        style: {\n          position: 'absolute',\n          pointerEvents: 'none',\n          width: '100%',\n          maxWidth: '100%',\n          display: 'block',\n          opacity: '0.333',\n          userSelect: 'none',\n          textDecoration: 'none'\n        },\n        contentEditable: false,\n        ref: placeholderRef\n      }\n    };\n    children = /*#__PURE__*/React.createElement(React.Fragment, null, renderPlaceholder(placeholderProps), children);\n  } // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n  // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n  // contenteditable behaviors. (2019/05/08)\n\n\n  var attributes = {\n    'data-slate-leaf': true\n  };\n  return renderLeaf({\n    attributes,\n    children,\n    leaf,\n    text\n  });\n};\n\nvar MemoizedLeaf = /*#__PURE__*/React.memo(Leaf, (prev, next) => {\n  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && Text$1.equals(next.leaf, prev.leaf) && next.leaf[PLACEHOLDER_SYMBOL] === prev.leaf[PLACEHOLDER_SYMBOL];\n});\nvar DefaultLeaf = props => {\n  var {\n    attributes,\n    children\n  } = props;\n  return /*#__PURE__*/React.createElement(\"span\", Object.assign({}, attributes), children);\n};\n\n/**\r\n * Text.\r\n */\n\nvar Text = props => {\n  var {\n    decorations,\n    isLast,\n    parent,\n    renderPlaceholder,\n    renderLeaf,\n    text\n  } = props;\n  var editor = useSlateStatic();\n  var ref = useRef(null);\n  var leaves = Text$1.decorations(text, decorations);\n  var key = ReactEditor.findKey(editor, text);\n  var children = [];\n\n  for (var i = 0; i < leaves.length; i++) {\n    var leaf = leaves[i];\n    children.push( /*#__PURE__*/React.createElement(MemoizedLeaf, {\n      isLast: isLast && i === leaves.length - 1,\n      key: \"\".concat(key.id, \"-\").concat(i),\n      renderPlaceholder: renderPlaceholder,\n      leaf: leaf,\n      text: text,\n      parent: parent,\n      renderLeaf: renderLeaf\n    }));\n  } // Update element-related weak maps with the DOM element ref.\n\n\n  useIsomorphicLayoutEffect(() => {\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n\n    if (ref.current) {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, ref.current);\n      NODE_TO_ELEMENT.set(text, ref.current);\n      ELEMENT_TO_NODE.set(ref.current, text);\n    } else {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);\n      NODE_TO_ELEMENT.delete(text);\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"span\", {\n    \"data-slate-node\": \"text\",\n    ref: ref\n  }, children);\n};\n\nvar MemoizedText = /*#__PURE__*/React.memo(Text, (prev, next) => {\n  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.text === prev.text && isDecoratorRangeListEqual(next.decorations, prev.decorations);\n});\n\n/**\r\n * Element.\r\n */\n\nvar Element = props => {\n  var {\n    decorations,\n    element,\n    renderElement = p => /*#__PURE__*/React.createElement(DefaultElement, Object.assign({}, p)),\n    renderPlaceholder,\n    renderLeaf,\n    selection\n  } = props;\n  var editor = useSlateStatic();\n  var readOnly = useReadOnly();\n  var isInline = editor.isInline(element);\n  var key = ReactEditor.findKey(editor, element);\n  var ref = useCallback(ref => {\n    // Update element-related weak maps with the DOM element ref.\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n\n    if (ref) {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, ref);\n      NODE_TO_ELEMENT.set(element, ref);\n      ELEMENT_TO_NODE.set(ref, element);\n    } else {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);\n      NODE_TO_ELEMENT.delete(element);\n    }\n  }, [editor, key, element]);\n  var children = useChildren({\n    decorations,\n    node: element,\n    renderElement,\n    renderPlaceholder,\n    renderLeaf,\n    selection\n  }); // Attributes that the developer must mix into the element in their\n  // custom node renderer component.\n\n  var attributes = {\n    'data-slate-node': 'element',\n    ref\n  };\n\n  if (isInline) {\n    attributes['data-slate-inline'] = true;\n  } // If it's a block node with inline children, add the proper `dir` attribute\n  // for text direction.\n\n\n  if (!isInline && Editor.hasInlines(editor, element)) {\n    var text = Node.string(element);\n    var dir = getDirection(text);\n\n    if (dir === 'rtl') {\n      attributes.dir = dir;\n    }\n  } // If it's a void node, wrap the children in extra void-specific elements.\n\n\n  if (Editor.isVoid(editor, element)) {\n    attributes['data-slate-void'] = true;\n\n    if (!readOnly && isInline) {\n      attributes.contentEditable = false;\n    }\n\n    var Tag = isInline ? 'span' : 'div';\n    var [[_text]] = Node.texts(element);\n    children = /*#__PURE__*/React.createElement(Tag, {\n      \"data-slate-spacer\": true,\n      style: {\n        height: '0',\n        color: 'transparent',\n        outline: 'none',\n        position: 'absolute'\n      }\n    }, /*#__PURE__*/React.createElement(MemoizedText, {\n      renderPlaceholder: renderPlaceholder,\n      decorations: [],\n      isLast: false,\n      parent: element,\n      text: _text\n    }));\n    NODE_TO_INDEX.set(_text, 0);\n    NODE_TO_PARENT.set(_text, element);\n  }\n\n  return renderElement({\n    attributes,\n    children,\n    element\n  });\n};\n\nvar MemoizedElement = /*#__PURE__*/React.memo(Element, (prev, next) => {\n  return prev.element === next.element && prev.renderElement === next.renderElement && prev.renderLeaf === next.renderLeaf && isDecoratorRangeListEqual(prev.decorations, next.decorations) && (prev.selection === next.selection || !!prev.selection && !!next.selection && Range.equals(prev.selection, next.selection));\n});\n/**\r\n * The default element renderer.\r\n */\n\nvar DefaultElement = props => {\n  var {\n    attributes,\n    children,\n    element\n  } = props;\n  var editor = useSlateStatic();\n  var Tag = editor.isInline(element) ? 'span' : 'div';\n  return /*#__PURE__*/React.createElement(Tag, Object.assign({}, attributes, {\n    style: {\n      position: 'relative'\n    }\n  }), children);\n};\n\n/**\r\n * A React context for sharing the `decorate` prop of the editable.\r\n */\n\nvar DecorateContext = /*#__PURE__*/createContext(() => []);\n/**\r\n * Get the current `decorate` prop of the editable.\r\n */\n\nvar useDecorate = () => {\n  return useContext(DecorateContext);\n};\n\n/**\r\n * A React context for sharing the `selected` state of an element.\r\n */\n\nvar SelectedContext = /*#__PURE__*/createContext(false);\n/**\r\n * Get the current `selected` state of an element.\r\n */\n\nvar useSelected = () => {\n  return useContext(SelectedContext);\n};\n\n/**\r\n * Children.\r\n */\n\nvar useChildren = props => {\n  var {\n    decorations,\n    node,\n    renderElement,\n    renderPlaceholder,\n    renderLeaf,\n    selection\n  } = props;\n  var decorate = useDecorate();\n  var editor = useSlateStatic();\n  var path = ReactEditor.findPath(editor, node);\n  var children = [];\n  var isLeafBlock = Element$1.isElement(node) && !editor.isInline(node) && Editor.hasInlines(editor, node);\n\n  for (var i = 0; i < node.children.length; i++) {\n    var p = path.concat(i);\n    var n = node.children[i];\n    var key = ReactEditor.findKey(editor, n);\n    var range = Editor.range(editor, p);\n    var sel = selection && Range.intersection(range, selection);\n    var ds = decorate([n, p]);\n\n    for (var dec of decorations) {\n      var d = Range.intersection(dec, range);\n\n      if (d) {\n        ds.push(d);\n      }\n    }\n\n    if (Element$1.isElement(n)) {\n      children.push( /*#__PURE__*/React.createElement(SelectedContext.Provider, {\n        key: \"provider-\".concat(key.id),\n        value: !!sel\n      }, /*#__PURE__*/React.createElement(MemoizedElement, {\n        decorations: ds,\n        element: n,\n        key: key.id,\n        renderElement: renderElement,\n        renderPlaceholder: renderPlaceholder,\n        renderLeaf: renderLeaf,\n        selection: sel\n      })));\n    } else {\n      children.push( /*#__PURE__*/React.createElement(MemoizedText, {\n        decorations: ds,\n        key: key.id,\n        isLast: isLeafBlock && i === node.children.length - 1,\n        parent: node,\n        renderPlaceholder: renderPlaceholder,\n        renderLeaf: renderLeaf,\n        text: n\n      }));\n    }\n\n    NODE_TO_INDEX.set(n, i);\n    NODE_TO_PARENT.set(n, node);\n  }\n\n  return children;\n};\n\n/**\r\n * A React context for sharing the `readOnly` state of the editor.\r\n */\n\nvar ReadOnlyContext = /*#__PURE__*/createContext(false);\n/**\r\n * Get the current `readOnly` state of the editor.\r\n */\n\nvar useReadOnly = () => {\n  return useContext(ReadOnlyContext);\n};\n\nvar SlateContext = /*#__PURE__*/createContext(null);\n/**\r\n * Get the current editor object from the React context.\r\n */\n\nvar useSlate = () => {\n  var context = useContext(SlateContext);\n\n  if (!context) {\n    throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n  }\n\n  var {\n    editor\n  } = context;\n  return editor;\n};\nvar useSlateWithV = () => {\n  var context = useContext(SlateContext);\n\n  if (!context) {\n    throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n  }\n\n  return context;\n};\n\nvar TRIPLE_CLICK = 3;\n\n/**\r\n * Hotkey mappings for each platform.\r\n */\n\nvar HOTKEYS = {\n  bold: 'mod+b',\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  moveBackward: 'left',\n  moveForward: 'right',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  italic: 'mod+i',\n  insertSoftBreak: 'shift+enter',\n  splitBlock: 'enter',\n  undo: 'mod+z'\n};\nvar APPLE_HOTKEYS = {\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t'\n};\nvar WINDOWS_HOTKEYS = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z']\n};\n/**\r\n * Create a platform-aware hotkey checker.\r\n */\n\nvar create = key => {\n  var generic = HOTKEYS[key];\n  var apple = APPLE_HOTKEYS[key];\n  var windows = WINDOWS_HOTKEYS[key];\n  var isGeneric = generic && isKeyHotkey(generic);\n  var isApple = apple && isKeyHotkey(apple);\n  var isWindows = windows && isKeyHotkey(windows);\n  return event => {\n    if (isGeneric && isGeneric(event)) return true;\n    if (IS_APPLE && isApple && isApple(event)) return true;\n    if (!IS_APPLE && isWindows && isWindows(event)) return true;\n    return false;\n  };\n};\n/**\r\n * Hotkeys.\r\n */\n\n\nvar Hotkeys = {\n  isBold: create('bold'),\n  isCompose: create('compose'),\n  isMoveBackward: create('moveBackward'),\n  isMoveForward: create('moveForward'),\n  isDeleteBackward: create('deleteBackward'),\n  isDeleteForward: create('deleteForward'),\n  isDeleteLineBackward: create('deleteLineBackward'),\n  isDeleteLineForward: create('deleteLineForward'),\n  isDeleteWordBackward: create('deleteWordBackward'),\n  isDeleteWordForward: create('deleteWordForward'),\n  isExtendBackward: create('extendBackward'),\n  isExtendForward: create('extendForward'),\n  isExtendLineBackward: create('extendLineBackward'),\n  isExtendLineForward: create('extendLineForward'),\n  isItalic: create('italic'),\n  isMoveLineBackward: create('moveLineBackward'),\n  isMoveLineForward: create('moveLineForward'),\n  isMoveWordBackward: create('moveWordBackward'),\n  isMoveWordForward: create('moveWordForward'),\n  isRedo: create('redo'),\n  isSoftBreak: create('insertSoftBreak'),\n  isSplitBlock: create('splitBlock'),\n  isTransposeCharacter: create('transposeCharacter'),\n  isUndo: create('undo')\n};\n\nvar createRestoreDomManager = (editor, receivedUserInput) => {\n  var bufferedMutations = [];\n\n  var clear = () => {\n    bufferedMutations = [];\n  };\n\n  var registerMutations = mutations => {\n    if (!receivedUserInput.current) {\n      return;\n    }\n\n    var trackedMutations = mutations.filter(mutation => isTrackedMutation(editor, mutation, mutations));\n    bufferedMutations.push(...trackedMutations);\n  };\n\n  function restoreDOM() {\n    bufferedMutations.reverse().forEach(mutation => {\n      if (mutation.type === 'characterData') {\n        mutation.target.textContent = mutation.oldValue;\n        return;\n      }\n\n      mutation.removedNodes.forEach(node => {\n        mutation.target.insertBefore(node, mutation.nextSibling);\n      });\n      mutation.addedNodes.forEach(node => {\n        mutation.target.removeChild(node);\n      });\n    }); // Clear buffered mutations to ensure we don't undo them twice\n\n    clear();\n  }\n\n  return {\n    registerMutations,\n    restoreDOM,\n    clear\n  };\n};\n\nvar MUTATION_OBSERVER_CONFIG$1 = {\n  subtree: true,\n  childList: true,\n  characterData: true,\n  characterDataOldValue: true\n}; // We have to use a class component here since we rely on `getSnapshotBeforeUpdate` which has no FC equivalent\n// to run code synchronously immediately before react commits the component update to the DOM.\n\nclass RestoreDOMComponent extends Component {\n  constructor() {\n    super(...arguments);\n    this.context = null;\n    this.manager = null;\n    this.mutationObserver = null;\n  }\n\n  observe() {\n    var _this$mutationObserve;\n\n    var {\n      node\n    } = this.props;\n\n    if (!node.current) {\n      throw new Error('Failed to attach MutationObserver, `node` is undefined');\n    }\n\n    (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 ? void 0 : _this$mutationObserve.observe(node.current, MUTATION_OBSERVER_CONFIG$1);\n  }\n\n  componentDidMount() {\n    var {\n      receivedUserInput\n    } = this.props;\n    var editor = this.context;\n    this.manager = createRestoreDomManager(editor, receivedUserInput);\n    this.mutationObserver = new MutationObserver(this.manager.registerMutations);\n    this.observe();\n  }\n\n  getSnapshotBeforeUpdate() {\n    var _this$mutationObserve2, _this$mutationObserve3, _this$manager2;\n\n    var pendingMutations = (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 ? void 0 : _this$mutationObserve2.takeRecords();\n\n    if (pendingMutations !== null && pendingMutations !== void 0 && pendingMutations.length) {\n      var _this$manager;\n\n      (_this$manager = this.manager) === null || _this$manager === void 0 ? void 0 : _this$manager.registerMutations(pendingMutations);\n    }\n\n    (_this$mutationObserve3 = this.mutationObserver) === null || _this$mutationObserve3 === void 0 ? void 0 : _this$mutationObserve3.disconnect();\n    (_this$manager2 = this.manager) === null || _this$manager2 === void 0 ? void 0 : _this$manager2.restoreDOM();\n    return null;\n  }\n\n  componentDidUpdate() {\n    var _this$manager3;\n\n    (_this$manager3 = this.manager) === null || _this$manager3 === void 0 ? void 0 : _this$manager3.clear();\n    this.observe();\n  }\n\n  componentWillUnmount() {\n    var _this$mutationObserve4;\n\n    (_this$mutationObserve4 = this.mutationObserver) === null || _this$mutationObserve4 === void 0 ? void 0 : _this$mutationObserve4.disconnect();\n  }\n\n  render() {\n    return this.props.children;\n  }\n\n}\n\nRestoreDOMComponent.contextType = EditorContext;\nvar RestoreDOM = IS_ANDROID ? RestoreDOMComponent : _ref => {\n  var {\n    children\n  } = _ref;\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n};\n\n/**\r\n * Check whether a text diff was applied in a way we can perform the pending action on /\r\n * recover the pending selection.\r\n */\n\nfunction verifyDiffState(editor, textDiff) {\n  var {\n    path,\n    diff\n  } = textDiff;\n\n  if (!Editor.hasPath(editor, path)) {\n    return false;\n  }\n\n  var node = Node.get(editor, path);\n\n  if (!Text$1.isText(node)) {\n    return false;\n  }\n\n  if (diff.start !== node.text.length || diff.text.length === 0) {\n    return node.text.slice(diff.start, diff.start + diff.text.length) === diff.text;\n  }\n\n  var nextPath = Path.next(path);\n\n  if (!Editor.hasPath(editor, nextPath)) {\n    return false;\n  }\n\n  var nextNode = Node.get(editor, nextPath);\n  return Text$1.isText(nextNode) && nextNode.text.startsWith(diff.text);\n}\n\nfunction applyStringDiff(text) {\n  for (var _len = arguments.length, diffs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    diffs[_key - 1] = arguments[_key];\n  }\n\n  return diffs.reduce((text, diff) => text.slice(0, diff.start) + diff.text + text.slice(diff.end), text);\n}\n\nfunction longestCommonPrefixLength(str, another) {\n  var length = Math.min(str.length, another.length);\n\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(i) !== another.charAt(i)) {\n      return i;\n    }\n  }\n\n  return length;\n}\n\nfunction longestCommonSuffixLength(str, another, max) {\n  var length = Math.min(str.length, another.length, max);\n\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(str.length - i - 1) !== another.charAt(another.length - i - 1)) {\n      return i;\n    }\n  }\n\n  return length;\n}\n/**\r\n * Remove redundant changes from the diff so that it spans the minimal possible range\r\n */\n\n\nfunction normalizeStringDiff(targetText, diff) {\n  var {\n    start,\n    end,\n    text\n  } = diff;\n  var removedText = targetText.slice(start, end);\n  var prefixLength = longestCommonPrefixLength(removedText, text);\n  var max = Math.min(removedText.length - prefixLength, text.length - prefixLength);\n  var suffixLength = longestCommonSuffixLength(removedText, text, max);\n  var normalized = {\n    start: start + prefixLength,\n    end: end - suffixLength,\n    text: text.slice(prefixLength, text.length - suffixLength)\n  };\n\n  if (normalized.start === normalized.end && normalized.text.length === 0) {\n    return null;\n  }\n\n  return normalized;\n}\n/**\r\n * Return a string diff that is equivalent to applying b after a spanning the range of\r\n * both changes\r\n */\n\nfunction mergeStringDiffs(targetText, a, b) {\n  var start = Math.min(a.start, b.start);\n  var overlap = Math.max(0, Math.min(a.start + a.text.length, b.end) - b.start);\n  var applied = applyStringDiff(targetText, a, b);\n  var sliceEnd = Math.max(b.start + b.text.length, a.start + a.text.length + (a.start + a.text.length > b.start ? b.text.length : 0) - overlap);\n  var text = applied.slice(start, sliceEnd);\n  var end = Math.max(a.end, b.end - a.text.length + (a.end - a.start));\n  return normalizeStringDiff(targetText, {\n    start,\n    end,\n    text\n  });\n}\n/**\r\n * Get the slate range the text diff spans.\r\n */\n\nfunction targetRange(textDiff) {\n  var {\n    path,\n    diff\n  } = textDiff;\n  return {\n    anchor: {\n      path,\n      offset: diff.start\n    },\n    focus: {\n      path,\n      offset: diff.end\n    }\n  };\n}\n/**\r\n * Normalize a 'pending point' a.k.a a point based on the dom state before applying\r\n * the pending diffs. Since the pending diffs might have been inserted with different\r\n * marks we have to 'walk' the offset from the starting position to ensure we still\r\n * have a valid point inside the document\r\n */\n\nfunction normalizePoint(editor, point) {\n  var {\n    path,\n    offset\n  } = point;\n\n  if (!Editor.hasPath(editor, path)) {\n    return null;\n  }\n\n  var leaf = Node.get(editor, path);\n\n  if (!Text$1.isText(leaf)) {\n    return null;\n  }\n\n  var parentBlock = Editor.above(editor, {\n    match: n => Editor.isBlock(editor, n),\n    at: path\n  });\n\n  if (!parentBlock) {\n    return null;\n  }\n\n  while (offset > leaf.text.length) {\n    var entry = Editor.next(editor, {\n      at: path,\n      match: Text$1.isText\n    });\n\n    if (!entry || !Path.isDescendant(entry[1], parentBlock[1])) {\n      return null;\n    }\n\n    offset -= leaf.text.length;\n    leaf = entry[0];\n    path = entry[1];\n  }\n\n  return {\n    path,\n    offset\n  };\n}\n/**\r\n * Normalize a 'pending selection' to ensure it's valid in the current document state.\r\n */\n\nfunction normalizeRange(editor, range) {\n  var anchor = normalizePoint(editor, range.anchor);\n\n  if (!anchor) {\n    return null;\n  }\n\n  if (Range.isCollapsed(range)) {\n    return {\n      anchor,\n      focus: anchor\n    };\n  }\n\n  var focus = normalizePoint(editor, range.focus);\n\n  if (!focus) {\n    return null;\n  }\n\n  return {\n    anchor,\n    focus\n  };\n}\nfunction transformPendingPoint(editor, point, op) {\n  var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n  var textDiff = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find(_ref => {\n    var {\n      path\n    } = _ref;\n    return Path.equals(path, point.path);\n  });\n\n  if (!textDiff || point.offset <= textDiff.diff.start) {\n    return Point.transform(point, op, {\n      affinity: 'backward'\n    });\n  }\n\n  var {\n    diff\n  } = textDiff; // Point references location inside the diff => transform the point based on the location\n  // the diff will be applied to and add the offset inside the diff.\n\n  if (point.offset <= diff.start + diff.text.length) {\n    var _anchor = {\n      path: point.path,\n      offset: diff.start\n    };\n\n    var _transformed = Point.transform(_anchor, op, {\n      affinity: 'backward'\n    });\n\n    if (!_transformed) {\n      return null;\n    }\n\n    return {\n      path: _transformed.path,\n      offset: _transformed.offset + point.offset - diff.start\n    };\n  } // Point references location after the diff\n\n\n  var anchor = {\n    path: point.path,\n    offset: point.offset - diff.text.length + diff.end - diff.start\n  };\n  var transformed = Point.transform(anchor, op, {\n    affinity: 'backward'\n  });\n\n  if (!transformed) {\n    return null;\n  }\n\n  if (op.type === 'split_node' && Path.equals(op.path, point.path) && anchor.offset < op.position && diff.start < op.position) {\n    return transformed;\n  }\n\n  return {\n    path: transformed.path,\n    offset: transformed.offset + diff.text.length - diff.end + diff.start\n  };\n}\nfunction transformPendingRange(editor, range, op) {\n  var anchor = transformPendingPoint(editor, range.anchor, op);\n\n  if (!anchor) {\n    return null;\n  }\n\n  if (Range.isCollapsed(range)) {\n    return {\n      anchor,\n      focus: anchor\n    };\n  }\n\n  var focus = transformPendingPoint(editor, range.focus, op);\n\n  if (!focus) {\n    return null;\n  }\n\n  return {\n    anchor,\n    focus\n  };\n}\nfunction transformTextDiff(textDiff, op) {\n  var {\n    path,\n    diff,\n    id\n  } = textDiff;\n\n  switch (op.type) {\n    case 'insert_text':\n      {\n        if (!Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n\n        if (op.offset <= diff.start) {\n          return {\n            diff: {\n              start: op.text.length + diff.start,\n              end: op.text.length + diff.end,\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end + op.text.length,\n            text: diff.text\n          },\n          id,\n          path\n        };\n      }\n\n    case 'remove_text':\n      {\n        if (!Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n\n        if (op.offset + op.text.length <= diff.start) {\n          return {\n            diff: {\n              start: diff.start - op.text.length,\n              end: diff.end - op.text.length,\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end - op.text.length,\n            text: diff.text\n          },\n          id,\n          path\n        };\n      }\n\n    case 'split_node':\n      {\n        if (!Path.equals(op.path, path) || op.position >= diff.end) {\n          return {\n            diff,\n            id,\n            path: Path.transform(path, op, {\n              affinity: 'backward'\n            })\n          };\n        }\n\n        if (op.position > diff.start) {\n          return {\n            diff: {\n              start: diff.start,\n              end: Math.min(op.position, diff.end),\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n\n        return {\n          diff: {\n            start: diff.start - op.position,\n            end: diff.end - op.position,\n            text: diff.text\n          },\n          id,\n          path: Path.transform(path, op, {\n            affinity: 'forward'\n          })\n        };\n      }\n\n    case 'merge_node':\n      {\n        if (!Path.equals(op.path, path)) {\n          return {\n            diff,\n            id,\n            path: Path.transform(path, op)\n          };\n        }\n\n        return {\n          diff: {\n            start: diff.start + op.position,\n            end: diff.end + op.position,\n            text: diff.text\n          },\n          id,\n          path: Path.transform(path, op)\n        };\n      }\n  }\n\n  var newPath = Path.transform(path, op);\n\n  if (!newPath) {\n    return null;\n  }\n\n  return {\n    diff,\n    path: newPath,\n    id\n  };\n}\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n// When using keyboard English association function, conpositionEnd triggered too fast, resulting in after `insertText` still maintain association state.\n\nvar RESOLVE_DELAY = 25; // Time with no user interaction before the current user action is considered as done.\n\nvar FLUSH_DELAY = 200; // Replace with `const debug = console.log` to debug\n\nvar debug = function debug() {};\n\nfunction createAndroidInputManager(_ref) {\n  var {\n    editor,\n    scheduleOnDOMSelectionChange,\n    onDOMSelectionChange\n  } = _ref;\n  var flushing = false;\n  var compositionEndTimeoutId = null;\n  var flushTimeoutId = null;\n  var actionTimeoutId = null;\n  var idCounter = 0;\n  var insertPositionHint = false;\n\n  var applyPendingSelection = () => {\n    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(editor);\n    EDITOR_TO_PENDING_SELECTION.delete(editor);\n\n    if (pendingSelection) {\n      var {\n        selection\n      } = editor;\n      var normalized = normalizeRange(editor, pendingSelection);\n\n      if (normalized && (!selection || !Range.equals(normalized, selection))) {\n        Transforms.select(editor, normalized);\n      }\n    }\n  };\n\n  var performAction = () => {\n    var action = EDITOR_TO_PENDING_ACTION.get(editor);\n    EDITOR_TO_PENDING_ACTION.delete(editor);\n\n    if (!action) {\n      return;\n    }\n\n    if (action.at) {\n      var target = Point.isPoint(action.at) ? normalizePoint(editor, action.at) : normalizeRange(editor, action.at);\n\n      if (!target) {\n        return;\n      }\n\n      var _targetRange = Editor.range(editor, target);\n\n      if (!editor.selection || !Range.equals(editor.selection, _targetRange)) {\n        Transforms.select(editor, target);\n      }\n    }\n\n    action.run();\n  };\n\n  var flush = () => {\n    var _EDITOR_TO_PENDING_DI;\n\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n\n    if (actionTimeoutId) {\n      clearTimeout(actionTimeoutId);\n      actionTimeoutId = null;\n    }\n\n    if (!hasPendingDiffs() && !hasPendingAction()) {\n      applyPendingSelection();\n      return;\n    }\n\n    if (!flushing) {\n      flushing = true;\n      setTimeout(() => flushing = false);\n    }\n\n    if (hasPendingAction()) {\n      flushing = 'action';\n    }\n\n    var selectionRef = editor.selection && Editor.rangeRef(editor, editor.selection, {\n      affinity: 'forward'\n    });\n    EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n    debug('flush', EDITOR_TO_PENDING_ACTION.get(editor), EDITOR_TO_PENDING_DIFFS.get(editor));\n    var scheduleSelectionChange = !!((_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length);\n    var diff;\n\n    while (diff = (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI2 === void 0 ? void 0 : _EDITOR_TO_PENDING_DI2[0]) {\n      var _EDITOR_TO_PENDING_DI2, _EDITOR_TO_PENDING_DI3;\n\n      var pendingMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n\n      if (pendingMarks !== undefined) {\n        EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n        editor.marks = pendingMarks;\n      }\n\n      if (pendingMarks && insertPositionHint === false) {\n        insertPositionHint = null;\n      }\n\n      var range = targetRange(diff);\n\n      if (!editor.selection || !Range.equals(editor.selection, range)) {\n        Transforms.select(editor, range);\n      }\n\n      if (diff.diff.text) {\n        Editor.insertText(editor, diff.diff.text);\n      } else {\n        Editor.deleteFragment(editor);\n      } // Remove diff only after we have applied it to account for it when transforming\n      // pending ranges.\n\n\n      EDITOR_TO_PENDING_DIFFS.set(editor, (_EDITOR_TO_PENDING_DI3 = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI3 === void 0 ? void 0 : _EDITOR_TO_PENDING_DI3.filter(_ref2 => {\n        var {\n          id\n        } = _ref2;\n        return id !== diff.id;\n      }));\n\n      if (!verifyDiffState(editor, diff)) {\n        scheduleSelectionChange = false;\n        EDITOR_TO_PENDING_ACTION.delete(editor);\n        EDITOR_TO_USER_MARKS.delete(editor);\n        flushing = 'action'; // Ensure we don't restore the pending user (dom) selection\n        // since the document and dom state do not match.\n\n        EDITOR_TO_PENDING_SELECTION.delete(editor);\n        scheduleOnDOMSelectionChange.cancel();\n        onDOMSelectionChange.cancel();\n        selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();\n      }\n    }\n\n    var selection = selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();\n\n    if (selection && !EDITOR_TO_PENDING_SELECTION.get(editor) && (!editor.selection || !Range.equals(selection, editor.selection))) {\n      Transforms.select(editor, selection);\n    }\n\n    if (hasPendingAction()) {\n      performAction();\n      return;\n    } // COMPAT: The selectionChange event is fired after the action is performed,\n    // so we have to manually schedule it to ensure we don't 'throw away' the selection\n    // while rendering if we have pending changes.\n\n\n    if (scheduleSelectionChange) {\n      scheduleOnDOMSelectionChange();\n    }\n\n    scheduleOnDOMSelectionChange.flush();\n    onDOMSelectionChange.flush();\n    applyPendingSelection();\n    var userMarks = EDITOR_TO_USER_MARKS.get(editor);\n    EDITOR_TO_USER_MARKS.delete(editor);\n\n    if (userMarks !== undefined) {\n      editor.marks = userMarks;\n      editor.onChange();\n    }\n  };\n\n  var handleCompositionEnd = _event => {\n    if (compositionEndTimeoutId) {\n      clearTimeout(compositionEndTimeoutId);\n    }\n\n    compositionEndTimeoutId = setTimeout(() => {\n      IS_COMPOSING.set(editor, false);\n      flush();\n    }, RESOLVE_DELAY);\n  };\n\n  var handleCompositionStart = _event => {\n    IS_COMPOSING.set(editor, true);\n\n    if (compositionEndTimeoutId) {\n      clearTimeout(compositionEndTimeoutId);\n      compositionEndTimeoutId = null;\n    }\n  };\n\n  var updatePlaceholderVisibility = function updatePlaceholderVisibility() {\n    var forceHide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var placeholderElement = EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor);\n\n    if (!placeholderElement) {\n      return;\n    }\n\n    if (hasPendingDiffs() || forceHide) {\n      placeholderElement.style.display = 'none';\n      return;\n    }\n\n    placeholderElement.style.removeProperty('display');\n  };\n\n  var storeDiff = (path, diff) => {\n    var _EDITOR_TO_PENDING_DI4;\n    var pendingDiffs = (_EDITOR_TO_PENDING_DI4 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI4 !== void 0 ? _EDITOR_TO_PENDING_DI4 : [];\n    EDITOR_TO_PENDING_DIFFS.set(editor, pendingDiffs);\n    var target = Node.leaf(editor, path);\n    var idx = pendingDiffs.findIndex(change => Path.equals(change.path, path));\n\n    if (idx < 0) {\n      var normalized = normalizeStringDiff(target.text, diff);\n\n      if (normalized) {\n        pendingDiffs.push({\n          path,\n          diff,\n          id: idCounter++\n        });\n      }\n\n      updatePlaceholderVisibility();\n      return;\n    }\n\n    var merged = mergeStringDiffs(target.text, pendingDiffs[idx].diff, diff);\n\n    if (!merged) {\n      pendingDiffs.splice(idx, 1);\n      updatePlaceholderVisibility();\n      return;\n    }\n\n    pendingDiffs[idx] = _objectSpread$3(_objectSpread$3({}, pendingDiffs[idx]), {}, {\n      diff: merged\n    });\n  };\n\n  var scheduleAction = function scheduleAction(run) {\n    var {\n      at\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    insertPositionHint = false;\n    EDITOR_TO_PENDING_SELECTION.delete(editor);\n    scheduleOnDOMSelectionChange.cancel();\n    onDOMSelectionChange.cancel();\n\n    if (hasPendingAction()) {\n      flush();\n    }\n\n    EDITOR_TO_PENDING_ACTION.set(editor, {\n      at,\n      run\n    }); // COMPAT: When deleting before a non-contenteditable element chrome only fires a beforeinput,\n    // (no input) and doesn't perform any dom mutations. Without a flush timeout we would never flush\n    // in this case and thus never actually perform the action.\n\n    actionTimeoutId = setTimeout(flush);\n  };\n\n  var handleDOMBeforeInput = event => {\n    var _targetRange2;\n\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n\n    var {\n      inputType: type\n    } = event;\n    var targetRange = null;\n    var data = event.dataTransfer || event.data || undefined;\n\n    if (insertPositionHint !== false && type !== 'insertText' && type !== 'insertCompositionText') {\n      insertPositionHint = false;\n    }\n\n    var [nativeTargetRange] = event.getTargetRanges();\n\n    if (nativeTargetRange) {\n      targetRange = ReactEditor.toSlateRange(editor, nativeTargetRange, {\n        exactMatch: false,\n        suppressThrow: true\n      });\n    } // COMPAT: SelectionChange event is fired after the action is performed, so we\n    // have to manually get the selection here to ensure it's up-to-date.\n\n\n    var window = ReactEditor.getWindow(editor);\n    var domSelection = window.getSelection();\n\n    if (!targetRange && domSelection) {\n      nativeTargetRange = domSelection;\n      targetRange = ReactEditor.toSlateRange(editor, domSelection, {\n        exactMatch: false,\n        suppressThrow: true\n      });\n    }\n\n    targetRange = (_targetRange2 = targetRange) !== null && _targetRange2 !== void 0 ? _targetRange2 : editor.selection;\n\n    if (!targetRange) {\n      return;\n    }\n\n    if (Range.isExpanded(targetRange) && type.startsWith('delete')) {\n      var [start, end] = Range.edges(targetRange);\n      var leaf = Node.leaf(editor, start.path);\n\n      if (leaf.text.length === start.offset && end.offset === 0) {\n        var next = Editor.next(editor, {\n          at: start.path,\n          match: Text$1.isText\n        });\n\n        if (next && Path.equals(next[1], end.path)) {\n          targetRange = {\n            anchor: end,\n            focus: end\n          };\n        }\n      }\n    }\n\n    if (Range.isExpanded(targetRange) && type.startsWith('delete')) {\n      if (Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n        var [_start, _end] = Range.edges(targetRange);\n        return storeDiff(targetRange.anchor.path, {\n          text: '',\n          end: _end.offset,\n          start: _start.offset\n        });\n      }\n\n      var direction = type.endsWith('Backward') ? 'backward' : 'forward';\n      return scheduleAction(() => Editor.deleteFragment(editor, {\n        direction\n      }), {\n        at: targetRange\n      });\n    }\n\n    switch (type) {\n      case 'deleteByComposition':\n      case 'deleteByCut':\n      case 'deleteByDrag':\n        {\n          return scheduleAction(() => Editor.deleteFragment(editor), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteContent':\n      case 'deleteContentForward':\n        {\n          var {\n            anchor\n          } = targetRange;\n\n          if (Range.isCollapsed(targetRange)) {\n            var targetNode = Node.leaf(editor, anchor.path);\n\n            if (anchor.offset < targetNode.text.length) {\n              return storeDiff(anchor.path, {\n                text: '',\n                start: anchor.offset,\n                end: anchor.offset + 1\n              });\n            }\n          }\n\n          return scheduleAction(() => Editor.deleteForward(editor), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteContentBackward':\n        {\n          var _nativeTargetRange;\n\n          var {\n            anchor: _anchor\n          } = targetRange; // If we have a mismatch between the native and slate selection being collapsed\n          // we are most likely deleting a zero-width placeholder and thus should perform it\n          // as an action to ensure correct behavior (mostly happens with mark placeholders)\n\n          var nativeCollapsed = isDOMSelection(nativeTargetRange) ? nativeTargetRange.isCollapsed : !!((_nativeTargetRange = nativeTargetRange) !== null && _nativeTargetRange !== void 0 && _nativeTargetRange.collapsed);\n\n          if (nativeCollapsed && Range.isCollapsed(targetRange) && _anchor.offset > 0) {\n            return storeDiff(_anchor.path, {\n              text: '',\n              start: _anchor.offset - 1,\n              end: _anchor.offset\n            });\n          }\n\n          return scheduleAction(() => Editor.deleteBackward(editor), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteEntireSoftLine':\n        {\n          return scheduleAction(() => {\n            Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n          }, {\n            at: targetRange\n          });\n        }\n\n      case 'deleteHardLineBackward':\n        {\n          return scheduleAction(() => Editor.deleteBackward(editor, {\n            unit: 'block'\n          }), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteSoftLineBackward':\n        {\n          return scheduleAction(() => Editor.deleteBackward(editor, {\n            unit: 'line'\n          }), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteHardLineForward':\n        {\n          return scheduleAction(() => Editor.deleteForward(editor, {\n            unit: 'block'\n          }), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteSoftLineForward':\n        {\n          return scheduleAction(() => Editor.deleteForward(editor, {\n            unit: 'line'\n          }), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteWordBackward':\n        {\n          return scheduleAction(() => Editor.deleteBackward(editor, {\n            unit: 'word'\n          }), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteWordForward':\n        {\n          return scheduleAction(() => Editor.deleteForward(editor, {\n            unit: 'word'\n          }), {\n            at: targetRange\n          });\n        }\n\n      case 'insertLineBreak':\n        {\n          return scheduleAction(() => Editor.insertSoftBreak(editor), {\n            at: targetRange\n          });\n        }\n\n      case 'insertParagraph':\n        {\n          return scheduleAction(() => Editor.insertBreak(editor), {\n            at: targetRange\n          });\n        }\n\n      case 'insertCompositionText':\n      case 'deleteCompositionText':\n      case 'insertFromComposition':\n      case 'insertFromDrop':\n      case 'insertFromPaste':\n      case 'insertFromYank':\n      case 'insertReplacementText':\n      case 'insertText':\n        {\n          if ((data === null || data === void 0 ? void 0 : data.constructor.name) === 'DataTransfer') {\n            return scheduleAction(() => ReactEditor.insertData(editor, data), {\n              at: targetRange\n            });\n          }\n\n          if (typeof data === 'string' && data.includes('\\n')) {\n            return scheduleAction(() => Editor.insertSoftBreak(editor), {\n              at: Range.end(targetRange)\n            });\n          }\n\n          var text = data !== null && data !== void 0 ? data : ''; // COMPAT: If we are writing inside a placeholder, the ime inserts the text inside\n          // the placeholder itself and thus includes the zero-width space inside edit events.\n\n          if (EDITOR_TO_PENDING_INSERTION_MARKS.get(editor)) {\n            text = text.replace('\\uFEFF', '');\n          }\n\n          if (Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n            var [_start2, _end2] = Range.edges(targetRange);\n            var diff = {\n              start: _start2.offset,\n              end: _end2.offset,\n              text\n            }; // COMPAT: Swiftkey has a weird bug where the target range of the 2nd word\n            // inserted after a mark placeholder is inserted with an anchor offset off by 1.\n            // So writing 'some text' will result in 'some ttext'. Luckily all 'normal' insert\n            // text events are fired with the correct target ranges, only the final 'insertComposition'\n            // isn't, so we can adjust the target range start offset if we are confident this is the\n            // swiftkey insert causing the issue.\n\n            if (text && insertPositionHint && type === 'insertCompositionText') {\n              var hintPosition = insertPositionHint.start + insertPositionHint.text.search(/\\S|$/);\n              var diffPosition = diff.start + diff.text.search(/\\S|$/);\n\n              if (diffPosition === hintPosition + 1 && diff.end === insertPositionHint.start + insertPositionHint.text.length) {\n                diff.start -= 1;\n                insertPositionHint = null;\n                scheduleFlush();\n              } else {\n                insertPositionHint = false;\n              }\n            } else if (type === 'insertText') {\n              if (insertPositionHint === null) {\n                insertPositionHint = diff;\n              } else if (insertPositionHint && Range.isCollapsed(targetRange) && insertPositionHint.end + insertPositionHint.text.length === _start2.offset) {\n                insertPositionHint = _objectSpread$3(_objectSpread$3({}, insertPositionHint), {}, {\n                  text: insertPositionHint.text + text\n                });\n              } else {\n                insertPositionHint = false;\n              }\n            } else {\n              insertPositionHint = false;\n            }\n\n            storeDiff(_start2.path, diff);\n            return;\n          }\n\n          return scheduleAction(() => Editor.insertText(editor, text), {\n            at: targetRange\n          });\n        }\n    }\n  };\n\n  var hasPendingAction = () => {\n    return !!EDITOR_TO_PENDING_ACTION.get(editor);\n  };\n\n  var hasPendingDiffs = () => {\n    var _EDITOR_TO_PENDING_DI5;\n\n    return !!((_EDITOR_TO_PENDING_DI5 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI5 !== void 0 && _EDITOR_TO_PENDING_DI5.length);\n  };\n\n  var hasPendingChanges = () => {\n    return hasPendingAction() || hasPendingDiffs();\n  };\n\n  var isFlushing = () => {\n    return flushing;\n  };\n\n  var handleUserSelect = range => {\n    EDITOR_TO_PENDING_SELECTION.set(editor, range);\n\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n\n    var {\n      selection\n    } = editor;\n\n    if (!range) {\n      return;\n    }\n\n    var pathChanged = !selection || !Path.equals(selection.anchor.path, range.anchor.path);\n    var parentPathChanged = !selection || !Path.equals(selection.anchor.path.slice(0, -1), range.anchor.path.slice(0, -1));\n\n    if (pathChanged && insertPositionHint || parentPathChanged) {\n      insertPositionHint = false;\n    }\n\n    if (pathChanged || !hasPendingDiffs()) {\n      flushTimeoutId = setTimeout(flush, FLUSH_DELAY);\n    }\n  };\n\n  var handleInput = () => {\n    if (hasPendingAction() || !hasPendingDiffs()) {\n      flush();\n    }\n  };\n\n  var handleKeyDown = _ => {\n    // COMPAT: Swiftkey closes the keyboard when typing inside a empty node\n    // directly next to a non-contenteditable element (= the placeholder).\n    // The only event fired soon enough for us to allow hiding the placeholder\n    // without swiftkey picking it up is the keydown event, so we have to hide it\n    // here. See https://github.com/ianstormtaylor/slate/pull/4988#issuecomment-1201050535\n    if (!hasPendingDiffs()) {\n      updatePlaceholderVisibility(true);\n      setTimeout(updatePlaceholderVisibility);\n    }\n  };\n\n  var scheduleFlush = () => {\n    if (!hasPendingAction()) {\n      actionTimeoutId = setTimeout(flush);\n    }\n  };\n\n  var handleDomMutations = mutations => {\n    if (hasPendingDiffs() || hasPendingAction()) {\n      return;\n    }\n\n    if (mutations.some(mutation => isTrackedMutation(editor, mutation, mutations))) {\n      var _EDITOR_TO_FORCE_REND;\n\n      // Cause a re-render to restore the dom state if we encounter tracked mutations without\n      // a corresponding pending action.\n      (_EDITOR_TO_FORCE_REND = EDITOR_TO_FORCE_RENDER.get(editor)) === null || _EDITOR_TO_FORCE_REND === void 0 ? void 0 : _EDITOR_TO_FORCE_REND();\n    }\n  };\n\n  return {\n    flush,\n    scheduleFlush,\n    hasPendingDiffs,\n    hasPendingAction,\n    hasPendingChanges,\n    isFlushing,\n    handleUserSelect,\n    handleCompositionEnd,\n    handleCompositionStart,\n    handleDOMBeforeInput,\n    handleKeyDown,\n    handleDomMutations,\n    handleInput\n  };\n}\n\nfunction useIsMounted() {\n  var isMountedRef = useRef(false);\n  useEffect(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  return isMountedRef.current;\n}\n\nfunction useMutationObserver(node, callback, options) {\n  var [mutationObserver] = useState(() => new MutationObserver(callback));\n  useIsomorphicLayoutEffect(() => {\n    // Discard mutations caused during render phase. This works due to react calling\n    // useLayoutEffect synchronously after the render phase before the next tick.\n    mutationObserver.takeRecords();\n  });\n  useEffect(() => {\n    if (!node.current) {\n      throw new Error('Failed to attach MutationObserver, `node` is undefined');\n    }\n\n    mutationObserver.observe(node.current, options);\n    return () => mutationObserver.disconnect();\n  }, []);\n}\n\nvar _excluded$2 = [\"node\"];\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar MUTATION_OBSERVER_CONFIG = {\n  subtree: true,\n  childList: true,\n  characterData: true\n};\nfunction useAndroidInputManager(_ref) {\n  var {\n    node\n  } = _ref,\n      options = _objectWithoutProperties(_ref, _excluded$2);\n\n  if (!IS_ANDROID) {\n    return null;\n  }\n\n  var editor = useSlateStatic();\n  var isMounted = useIsMounted();\n  var [inputManager] = useState(() => createAndroidInputManager(_objectSpread$2({\n    editor\n  }, options)));\n  useMutationObserver(node, inputManager.handleDomMutations, MUTATION_OBSERVER_CONFIG);\n  EDITOR_TO_SCHEDULE_FLUSH.set(editor, inputManager.scheduleFlush);\n\n  if (isMounted) {\n    inputManager.flush();\n  }\n\n  return inputManager;\n}\n\nfunction useTrackUserInput() {\n  var editor = useSlateStatic();\n  var receivedUserInput = useRef(false);\n  var animationFrameIdRef = useRef(0);\n  var onUserInput = useCallback(() => {\n    if (receivedUserInput.current) {\n      return;\n    }\n\n    receivedUserInput.current = true;\n    var window = ReactEditor.getWindow(editor);\n    window.cancelAnimationFrame(animationFrameIdRef.current);\n    animationFrameIdRef.current = window.requestAnimationFrame(() => {\n      receivedUserInput.current = false;\n    });\n  }, []);\n  useEffect(() => () => cancelAnimationFrame(animationFrameIdRef.current), []);\n  return {\n    receivedUserInput,\n    onUserInput\n  };\n}\n\nvar _excluded$1 = [\"autoFocus\", \"decorate\", \"onDOMBeforeInput\", \"placeholder\", \"readOnly\", \"renderElement\", \"renderLeaf\", \"renderPlaceholder\", \"scrollSelectionIntoView\", \"style\", \"as\"],\n    _excluded2 = [\"text\"];\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Children = props => /*#__PURE__*/React.createElement(React.Fragment, null, useChildren(props)); // The number of Editable components currently mounted.\n\n\nvar mountedCount = 0;\n/**\r\n * Editable.\r\n */\n\nvar Editable = props => {\n  var {\n    autoFocus,\n    decorate = defaultDecorate,\n    onDOMBeforeInput: propsOnDOMBeforeInput,\n    placeholder,\n    readOnly = false,\n    renderElement,\n    renderLeaf,\n    renderPlaceholder = props => /*#__PURE__*/React.createElement(DefaultPlaceholder, Object.assign({}, props)),\n    scrollSelectionIntoView = defaultScrollSelectionIntoView,\n    style = {},\n    as: Component = 'div'\n  } = props,\n      attributes = _objectWithoutProperties(props, _excluded$1);\n\n  var editor = useSlate(); // Rerender editor when composition status changed\n\n  var [isComposing, setIsComposing] = useState(false);\n  var ref = useRef(null);\n  var deferredOperations = useRef([]);\n  var {\n    onUserInput,\n    receivedUserInput\n  } = useTrackUserInput();\n  var [, forceRender] = useReducer(s => s + 1, 0);\n  EDITOR_TO_FORCE_RENDER.set(editor, forceRender); // Update internal state on each render.\n\n  IS_READ_ONLY.set(editor, readOnly); // Keep track of some state for the event handler logic.\n\n  var state = useMemo(() => ({\n    isDraggingInternally: false,\n    isUpdatingSelection: false,\n    latestElement: null,\n    hasMarkPlaceholder: false\n  }), []); // The autoFocus TextareaHTMLAttribute doesn't do anything on a div, so it\n  // needs to be manually focused.\n\n  useEffect(() => {\n    if (ref.current && autoFocus) {\n      ref.current.focus();\n    }\n  }, [autoFocus]); // Listen on the native `selectionchange` event to be able to update any time\n  // the selection changes. This is required because React's `onSelect` is leaky\n  // and non-standard so it doesn't fire until after a selection has been\n  // released. This causes issues in situations where another change happens\n  // while a selection is being dragged.\n\n  var onDOMSelectionChange = useCallback(throttle(() => {\n    if ((IS_ANDROID || !ReactEditor.isComposing(editor)) && (!state.isUpdatingSelection || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing()) && !state.isDraggingInternally) {\n      var root = ReactEditor.findDocumentOrShadowRoot(editor);\n      var {\n        activeElement\n      } = root;\n      var el = ReactEditor.toDOMNode(editor, editor);\n      var domSelection = root.getSelection();\n\n      if (activeElement === el) {\n        state.latestElement = activeElement;\n        IS_FOCUSED.set(editor, true);\n      } else {\n        IS_FOCUSED.delete(editor);\n      }\n\n      if (!domSelection) {\n        return Transforms.deselect(editor);\n      }\n\n      var {\n        anchorNode,\n        focusNode\n      } = domSelection;\n      var anchorNodeSelectable = ReactEditor.hasEditableTarget(editor, anchorNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, anchorNode);\n      var focusNodeSelectable = ReactEditor.hasEditableTarget(editor, focusNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, focusNode);\n\n      if (anchorNodeSelectable && focusNodeSelectable) {\n        var range = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: false,\n          suppressThrow: true\n        });\n\n        if (range) {\n          if (!ReactEditor.isComposing(editor) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingChanges()) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing())) {\n            Transforms.select(editor, range);\n          } else {\n            androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleUserSelect(range);\n          }\n        }\n      } // Deselect the editor if the dom selection is not selectable in readonly mode\n\n\n      if (readOnly && (!anchorNodeSelectable || !focusNodeSelectable)) {\n        Transforms.deselect(editor);\n      }\n    }\n  }, 100), [readOnly]);\n  var scheduleOnDOMSelectionChange = useMemo(() => debounce(onDOMSelectionChange, 0), [onDOMSelectionChange]);\n  var androidInputManager = useAndroidInputManager({\n    node: ref,\n    onDOMSelectionChange,\n    scheduleOnDOMSelectionChange\n  });\n  useIsomorphicLayoutEffect(() => {\n    // Update element-related weak maps with the DOM element ref.\n    var window;\n\n    if (ref.current && (window = getDefaultView(ref.current))) {\n      EDITOR_TO_WINDOW.set(editor, window);\n      EDITOR_TO_ELEMENT.set(editor, ref.current);\n      NODE_TO_ELEMENT.set(editor, ref.current);\n      ELEMENT_TO_NODE.set(ref.current, editor);\n    } else {\n      NODE_TO_ELEMENT.delete(editor);\n    } // Make sure the DOM selection state is in sync.\n\n\n    var {\n      selection\n    } = editor;\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = root.getSelection();\n\n    if (!domSelection || !ReactEditor.isFocused(editor) || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingAction()) {\n      return;\n    }\n\n    var setDomSelection = forceChange => {\n      var hasDomSelection = domSelection.type !== 'None'; // If the DOM selection is properly unset, we're done.\n\n      if (!selection && !hasDomSelection) {\n        return;\n      } // verify that the dom selection is in the editor\n\n\n      var editorElement = EDITOR_TO_ELEMENT.get(editor);\n      var hasDomSelectionInEditor = false;\n\n      if (editorElement.contains(domSelection.anchorNode) && editorElement.contains(domSelection.focusNode)) {\n        hasDomSelectionInEditor = true;\n      } // If the DOM selection is in the editor and the editor selection is already correct, we're done.\n\n\n      if (hasDomSelection && hasDomSelectionInEditor && selection && !forceChange) {\n        var slateRange = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: true,\n          // domSelection is not necessarily a valid Slate range\n          // (e.g. when clicking on contentEditable:false element)\n          suppressThrow: true\n        });\n\n        if (slateRange && Range.equals(slateRange, selection)) {\n          var _anchorNode$parentEle;\n\n          if (!state.hasMarkPlaceholder) {\n            return;\n          } // Ensure selection is inside the mark placeholder\n\n\n          var {\n            anchorNode\n          } = domSelection;\n\n          if (anchorNode !== null && anchorNode !== void 0 && (_anchorNode$parentEle = anchorNode.parentElement) !== null && _anchorNode$parentEle !== void 0 && _anchorNode$parentEle.hasAttribute('data-slate-mark-placeholder')) {\n            return;\n          }\n        }\n      } // when <Editable/> is being controlled through external value\n      // then its children might just change - DOM responds to it on its own\n      // but Slate's value is not being updated through any operation\n      // and thus it doesn't transform selection on its own\n\n\n      if (selection && !ReactEditor.hasRange(editor, selection)) {\n        editor.selection = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: false,\n          suppressThrow: true\n        });\n        return;\n      } // Otherwise the DOM selection is out of sync, so update it.\n\n\n      state.isUpdatingSelection = true;\n      var newDomRange = selection && ReactEditor.toDOMRange(editor, selection);\n\n      if (newDomRange) {\n        if (Range.isBackward(selection)) {\n          domSelection.setBaseAndExtent(newDomRange.endContainer, newDomRange.endOffset, newDomRange.startContainer, newDomRange.startOffset);\n        } else {\n          domSelection.setBaseAndExtent(newDomRange.startContainer, newDomRange.startOffset, newDomRange.endContainer, newDomRange.endOffset);\n        }\n\n        scrollSelectionIntoView(editor, newDomRange);\n      } else {\n        domSelection.removeAllRanges();\n      }\n\n      return newDomRange;\n    };\n\n    var newDomRange = setDomSelection();\n    var ensureSelection = (androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.isFlushing()) === 'action';\n\n    if (!IS_ANDROID || !ensureSelection) {\n      setTimeout(() => {\n        // COMPAT: In Firefox, it's not enough to create a range, you also need\n        // to focus the contenteditable element too. (2016/11/16)\n        if (newDomRange && IS_FIREFOX) {\n          var el = ReactEditor.toDOMNode(editor, editor);\n          el.focus();\n        }\n\n        state.isUpdatingSelection = false;\n      });\n      return;\n    }\n\n    var timeoutId = null;\n    var animationFrameId = requestAnimationFrame(() => {\n      if (ensureSelection) {\n        var ensureDomSelection = forceChange => {\n          try {\n            var el = ReactEditor.toDOMNode(editor, editor);\n            el.focus();\n            setDomSelection(forceChange);\n          } catch (e) {// Ignore, dom and state might be out of sync\n          }\n        }; // Compat: Android IMEs try to force their selection by manually re-applying it even after we set it.\n        // This essentially would make setting the slate selection during an update meaningless, so we force it\n        // again here. We can't only do it in the setTimeout after the animation frame since that would cause a\n        // visible flicker.\n\n\n        ensureDomSelection();\n        timeoutId = setTimeout(() => {\n          // COMPAT: While setting the selection in an animation frame visually correctly sets the selection,\n          // it doesn't update GBoards spellchecker state. We have to manually trigger a selection change after\n          // the animation frame to ensure it displays the correct state.\n          ensureDomSelection(true);\n          state.isUpdatingSelection = false;\n        });\n      }\n    });\n    return () => {\n      cancelAnimationFrame(animationFrameId);\n\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    };\n  }); // Listen on the native `beforeinput` event to get real \"Level 2\" events. This\n  // is required because React's `beforeinput` is fake and never really attaches\n  // to the real event sadly. (2019/11/01)\n  // https://github.com/facebook/react/issues/11211\n\n  var onDOMBeforeInput = useCallback(event => {\n    onUserInput();\n\n    if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {\n      var _EDITOR_TO_USER_SELEC;\n\n      // COMPAT: BeforeInput events aren't cancelable on android, so we have to handle them differently using the android input manager.\n      if (androidInputManager) {\n        return androidInputManager.handleDOMBeforeInput(event);\n      } // Some IMEs/Chrome extensions like e.g. Grammarly set the selection immediately before\n      // triggering a `beforeinput` expecting the change to be applied to the immediately before\n      // set selection.\n\n\n      scheduleOnDOMSelectionChange.flush();\n      onDOMSelectionChange.flush();\n      var {\n        selection\n      } = editor;\n      var {\n        inputType: type\n      } = event;\n      var data = event.dataTransfer || event.data || undefined;\n      var isCompositionChange = type === 'insertCompositionText' || type === 'deleteCompositionText'; // COMPAT: use composition change events as a hint to where we should insert\n      // composition text if we aren't composing to work around https://github.com/ianstormtaylor/slate/issues/5038\n\n      if (isCompositionChange && ReactEditor.isComposing(editor)) {\n        return;\n      }\n\n      var native = false;\n\n      if (type === 'insertText' && selection && Range.isCollapsed(selection) && // Only use native character insertion for single characters a-z or space for now.\n      // Long-press events (hold a + press 4 = ) to choose a special character otherwise\n      // causes duplicate inserts.\n      event.data && event.data.length === 1 && /[a-z ]/i.test(event.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405\n      // When there is an inline element, e.g. a link, and you select\n      // right after it (the start of the next node).\n      selection.anchor.offset !== 0) {\n        var _node$parentElement, _window$getComputedSt;\n\n        native = true; // Skip native if there are marks, as\n        // `insertText` will insert a node, not just text.\n\n        if (editor.marks) {\n          native = false;\n        } // Chrome also has issues correctly editing the end of anchor elements: https://bugs.chromium.org/p/chromium/issues/detail?id=1259100\n        // Therefore we don't allow native events to insert text at the end of anchor nodes.\n\n\n        var {\n          anchor\n        } = selection;\n        var [node, offset] = ReactEditor.toDOMPoint(editor, anchor);\n        var anchorNode = (_node$parentElement = node.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.closest('a');\n        var window = ReactEditor.getWindow(editor);\n\n        if (native && anchorNode && ReactEditor.hasDOMNode(editor, anchorNode)) {\n          var _lastText$textContent;\n\n          // Find the last text node inside the anchor.\n          var lastText = window === null || window === void 0 ? void 0 : window.document.createTreeWalker(anchorNode, NodeFilter.SHOW_TEXT).lastChild();\n\n          if (lastText === node && ((_lastText$textContent = lastText.textContent) === null || _lastText$textContent === void 0 ? void 0 : _lastText$textContent.length) === offset) {\n            native = false;\n          }\n        } // Chrome has issues with the presence of tab characters inside elements with whiteSpace = 'pre'\n        // causing abnormal insert behavior: https://bugs.chromium.org/p/chromium/issues/detail?id=1219139\n\n\n        if (native && node.parentElement && (window === null || window === void 0 ? void 0 : (_window$getComputedSt = window.getComputedStyle(node.parentElement)) === null || _window$getComputedSt === void 0 ? void 0 : _window$getComputedSt.whiteSpace) === 'pre') {\n          var block = Editor.above(editor, {\n            at: anchor.path,\n            match: n => Editor.isBlock(editor, n)\n          });\n\n          if (block && Node.string(block[0]).includes('\\t')) {\n            native = false;\n          }\n        }\n      } // COMPAT: For the deleting forward/backward input types we don't want\n      // to change the selection because it is the range that will be deleted,\n      // and those commands determine that for themselves.\n\n\n      if (!type.startsWith('delete') || type.startsWith('deleteBy')) {\n        var [targetRange] = event.getTargetRanges();\n\n        if (targetRange) {\n          var range = ReactEditor.toSlateRange(editor, targetRange, {\n            exactMatch: false,\n            suppressThrow: false\n          });\n\n          if (!selection || !Range.equals(selection, range)) {\n            native = false;\n            var selectionRef = !isCompositionChange && editor.selection && Editor.rangeRef(editor, editor.selection);\n            Transforms.select(editor, range);\n\n            if (selectionRef) {\n              EDITOR_TO_USER_SELECTION.set(editor, selectionRef);\n            }\n          }\n        }\n      } // Composition change types occur while a user is composing text and can't be\n      // cancelled. Let them through and wait for the composition to end.\n\n\n      if (isCompositionChange) {\n        return;\n      }\n\n      if (!native) {\n        event.preventDefault();\n      } // COMPAT: If the selection is expanded, even if the command seems like\n      // a delete forward/backward command it should delete the selection.\n\n\n      if (selection && Range.isExpanded(selection) && type.startsWith('delete')) {\n        var direction = type.endsWith('Backward') ? 'backward' : 'forward';\n        Editor.deleteFragment(editor, {\n          direction\n        });\n        return;\n      }\n\n      switch (type) {\n        case 'deleteByComposition':\n        case 'deleteByCut':\n        case 'deleteByDrag':\n          {\n            Editor.deleteFragment(editor);\n            break;\n          }\n\n        case 'deleteContent':\n        case 'deleteContentForward':\n          {\n            Editor.deleteForward(editor);\n            break;\n          }\n\n        case 'deleteContentBackward':\n          {\n            Editor.deleteBackward(editor);\n            break;\n          }\n\n        case 'deleteEntireSoftLine':\n          {\n            Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n\n        case 'deleteHardLineBackward':\n          {\n            Editor.deleteBackward(editor, {\n              unit: 'block'\n            });\n            break;\n          }\n\n        case 'deleteSoftLineBackward':\n          {\n            Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n\n        case 'deleteHardLineForward':\n          {\n            Editor.deleteForward(editor, {\n              unit: 'block'\n            });\n            break;\n          }\n\n        case 'deleteSoftLineForward':\n          {\n            Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n\n        case 'deleteWordBackward':\n          {\n            Editor.deleteBackward(editor, {\n              unit: 'word'\n            });\n            break;\n          }\n\n        case 'deleteWordForward':\n          {\n            Editor.deleteForward(editor, {\n              unit: 'word'\n            });\n            break;\n          }\n\n        case 'insertLineBreak':\n          Editor.insertSoftBreak(editor);\n          break;\n\n        case 'insertParagraph':\n          {\n            Editor.insertBreak(editor);\n            break;\n          }\n\n        case 'insertFromComposition':\n        case 'insertFromDrop':\n        case 'insertFromPaste':\n        case 'insertFromYank':\n        case 'insertReplacementText':\n        case 'insertText':\n          {\n            if (type === 'insertFromComposition') {\n              // COMPAT: in Safari, `compositionend` is dispatched after the\n              // `beforeinput` for \"insertFromComposition\". But if we wait for it\n              // then we will abort because we're still composing and the selection\n              // won't be updated properly.\n              // https://www.w3.org/TR/input-events-2/\n              if (ReactEditor.isComposing(editor)) {\n                setIsComposing(false);\n                IS_COMPOSING.set(editor, false);\n              }\n            } // use a weak comparison instead of 'instanceof' to allow\n            // programmatic access of paste events coming from external windows\n            // like cypress where cy.window does not work realibly\n\n\n            if ((data === null || data === void 0 ? void 0 : data.constructor.name) === 'DataTransfer') {\n              ReactEditor.insertData(editor, data);\n            } else if (typeof data === 'string') {\n              // Only insertText operations use the native functionality, for now.\n              // Potentially expand to single character deletes, as well.\n              if (native) {\n                deferredOperations.current.push(() => Editor.insertText(editor, data));\n              } else {\n                Editor.insertText(editor, data);\n              }\n            }\n\n            break;\n          }\n      } // Restore the actual user section if nothing manually set it.\n\n\n      var toRestore = (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();\n      EDITOR_TO_USER_SELECTION.delete(editor);\n\n      if (toRestore && (!editor.selection || !Range.equals(editor.selection, toRestore))) {\n        Transforms.select(editor, toRestore);\n      }\n    }\n  }, [readOnly, propsOnDOMBeforeInput]); // Attach a native DOM event handler for `beforeinput` events, because React's\n  // built-in `onBeforeInput` is actually a leaky polyfill that doesn't expose\n  // real `beforeinput` events sadly... (2019/11/04)\n  // https://github.com/facebook/react/issues/11211\n\n  useIsomorphicLayoutEffect(() => {\n    if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {\n      // @ts-ignore The `beforeinput` event isn't recognized.\n      ref.current.addEventListener('beforeinput', onDOMBeforeInput);\n    }\n\n    return () => {\n      if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {\n        // @ts-ignore The `beforeinput` event isn't recognized.\n        ref.current.removeEventListener('beforeinput', onDOMBeforeInput);\n      }\n    };\n  }, [onDOMBeforeInput]); // Attach a native DOM event handler for `selectionchange`, because React's\n  // built-in `onSelect` handler doesn't fire for all selection changes. It's a\n  // leaky polyfill that only fires on keypresses or clicks. Instead, we want to\n  // fire for any change to the selection inside the editor. (2019/11/04)\n  // https://github.com/facebook/react/issues/5785\n\n  useIsomorphicLayoutEffect(() => {\n    var window = ReactEditor.getWindow(editor);\n    window.document.addEventListener('selectionchange', scheduleOnDOMSelectionChange);\n    return () => {\n      window.document.removeEventListener('selectionchange', scheduleOnDOMSelectionChange);\n    };\n  }, [scheduleOnDOMSelectionChange]);\n  var decorations = decorate([editor, []]);\n\n  if (placeholder && editor.children.length === 1 && Array.from(Node.texts(editor)).length === 1 && Node.string(editor) === '' && !isComposing) {\n    var start = Editor.start(editor, []);\n    decorations.push({\n      [PLACEHOLDER_SYMBOL]: true,\n      placeholder,\n      anchor: start,\n      focus: start\n    });\n  }\n\n  var {\n    marks\n  } = editor;\n  state.hasMarkPlaceholder = false;\n\n  if (editor.selection && Range.isCollapsed(editor.selection) && marks) {\n    var {\n      anchor\n    } = editor.selection;\n    var leaf = Node.leaf(editor, anchor.path);\n\n    var rest = _objectWithoutProperties(leaf, _excluded2); // While marks isn't a 'complete' text, we can still use loose Text.equals\n    // here which only compares marks anyway.\n\n\n    if (!Text$1.equals(leaf, marks, {\n      loose: true\n    })) {\n      state.hasMarkPlaceholder = true;\n      var unset = Object.fromEntries(Object.keys(rest).map(mark => [mark, null]));\n      decorations.push(_objectSpread$1(_objectSpread$1(_objectSpread$1({\n        [MARK_PLACEHOLDER_SYMBOL]: true\n      }, unset), marks), {}, {\n        anchor,\n        focus: anchor\n      }));\n    }\n  } // Update EDITOR_TO_MARK_PLACEHOLDER_MARKS in setTimeout useEffect to ensure we don't set it\n  // before we receive the composition end event.\n\n\n  useEffect(() => {\n    setTimeout(() => {\n      var {\n        selection\n      } = editor;\n\n      if (selection) {\n        var {\n          anchor: _anchor\n        } = selection;\n\n        var _text = Node.leaf(editor, _anchor.path); // While marks isn't a 'complete' text, we can still use loose Text.equals\n        // here which only compares marks anyway.\n\n\n        if (marks && !Text$1.equals(_text, marks, {\n          loose: true\n        })) {\n          EDITOR_TO_PENDING_INSERTION_MARKS.set(editor, marks);\n          return;\n        }\n      }\n\n      EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n    });\n  });\n  useEffect(() => {\n    mountedCount++;\n\n    if (mountedCount === 1) {\n      // Set global default styles for editors.\n      var defaultStylesElement = document.createElement('style');\n      defaultStylesElement.setAttribute('data-slate-default-styles', 'true');\n      defaultStylesElement.innerHTML = // :where is used to give these rules lower specificity so user stylesheets can override them.\n      \":where([data-slate-editor]) {\" + // Allow positioning relative to the editable element.\n      \"position: relative;\" + // Prevent the default outline styles.\n      \"outline: none;\" + // Preserve adjacent whitespace and new lines.\n      \"white-space: pre-wrap;\" + // Allow words to break if they are too long.\n      \"word-wrap: break-word;\" + \"}\";\n      document.head.appendChild(defaultStylesElement);\n    }\n\n    return () => {\n      var _document$querySelect;\n\n      mountedCount--;\n      if (mountedCount <= 0) (_document$querySelect = document.querySelector('style[data-slate-default-styles]')) === null || _document$querySelect === void 0 ? void 0 : _document$querySelect.remove();\n    };\n  }, []);\n  useEffect(() => {\n    var styleElement = document.createElement('style');\n    document.head.appendChild(styleElement);\n    EDITOR_TO_STYLE_ELEMENT.set(editor, styleElement);\n    return () => {\n      styleElement.remove();\n      EDITOR_TO_STYLE_ELEMENT.delete(editor);\n    };\n  }, []);\n  return /*#__PURE__*/React.createElement(ReadOnlyContext.Provider, {\n    value: readOnly\n  }, /*#__PURE__*/React.createElement(DecorateContext.Provider, {\n    value: decorate\n  }, /*#__PURE__*/React.createElement(RestoreDOM, {\n    node: ref,\n    receivedUserInput: receivedUserInput\n  }, /*#__PURE__*/React.createElement(Component, Object.assign({\n    role: readOnly ? undefined : 'textbox',\n    \"aria-multiline\": readOnly ? undefined : true\n  }, attributes, {\n    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd\n    // have to use hacks to make these replacement-based features work.\n    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop\n    // mismatch warning app moves to browser. Pass-through consumer props when\n    // not CAN_USE_DOM (SSR) and default to falsy value\n    spellCheck: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.spellCheck : false,\n    autoCorrect: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCorrect : 'false',\n    autoCapitalize: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCapitalize : 'false',\n    \"data-slate-editor\": true,\n    \"data-slate-editor-id\": editor.id,\n    \"data-slate-node\": \"value\",\n    // explicitly set this\n    contentEditable: !readOnly,\n    // in some cases, a decoration needs access to the range / selection to decorate a text node,\n    // then you will select the whole text node when you select part the of text\n    // this magic zIndex=\"-1\" will fix it\n    zindex: -1,\n    suppressContentEditableWarning: true,\n    ref: ref,\n    style: style,\n    onBeforeInput: useCallback(event => {\n      // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n      // fall back to React's leaky polyfill instead just for it. It\n      // only works for the `insertText` input type.\n      if (!HAS_BEFORE_INPUT_SUPPORT && !readOnly && !isEventHandled(event, attributes.onBeforeInput) && ReactEditor.hasSelectableTarget(editor, event.target)) {\n        event.preventDefault();\n\n        if (!ReactEditor.isComposing(editor)) {\n          var _text2 = event.data;\n          Editor.insertText(editor, _text2);\n        }\n      }\n    }, [readOnly]),\n    onInput: useCallback(event => {\n      if (androidInputManager) {\n        androidInputManager.handleInput();\n        return;\n      } // Flush native operations, as native events will have propogated\n      // and we can correctly compare DOM text values in components\n      // to stop rendering, so that browser functions like autocorrect\n      // and spellcheck work as expected.\n\n\n      for (var op of deferredOperations.current) {\n        op();\n      }\n\n      deferredOperations.current = [];\n    }, []),\n    onBlur: useCallback(event => {\n      if (readOnly || state.isUpdatingSelection || !ReactEditor.hasSelectableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {\n        return;\n      } // COMPAT: If the current `activeElement` is still the previous\n      // one, this is due to the window being blurred when the tab\n      // itself becomes unfocused, so we want to abort early to allow to\n      // editor to stay focused when the tab becomes focused again.\n\n\n      var root = ReactEditor.findDocumentOrShadowRoot(editor);\n\n      if (state.latestElement === root.activeElement) {\n        return;\n      }\n\n      var {\n        relatedTarget\n      } = event;\n      var el = ReactEditor.toDOMNode(editor, editor); // COMPAT: The event should be ignored if the focus is returning\n      // to the editor from an embedded editable element (eg. an <input>\n      // element inside a void node).\n\n      if (relatedTarget === el) {\n        return;\n      } // COMPAT: The event should be ignored if the focus is moving from\n      // the editor to inside a void node's spacer element.\n\n\n      if (isDOMElement(relatedTarget) && relatedTarget.hasAttribute('data-slate-spacer')) {\n        return;\n      } // COMPAT: The event should be ignored if the focus is moving to a\n      // non- editable section of an element that isn't a void node (eg.\n      // a list item of the check list example).\n\n\n      if (relatedTarget != null && isDOMNode(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {\n        var node = ReactEditor.toSlateNode(editor, relatedTarget);\n\n        if (Element$1.isElement(node) && !editor.isVoid(node)) {\n          return;\n        }\n      } // COMPAT: Safari doesn't always remove the selection even if the content-\n      // editable element no longer has focus. Refer to:\n      // https://stackoverflow.com/questions/12353247/force-contenteditable-div-to-stop-accepting-input-after-it-loses-focus-under-web\n\n\n      if (IS_SAFARI) {\n        var domSelection = root.getSelection();\n        domSelection === null || domSelection === void 0 ? void 0 : domSelection.removeAllRanges();\n      }\n\n      IS_FOCUSED.delete(editor);\n    }, [readOnly, attributes.onBlur]),\n    onClick: useCallback(event => {\n      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && isDOMNode(event.target)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node); // At this time, the Slate document may be arbitrarily different,\n        // because onClick handlers can change the document before we get here.\n        // Therefore we must check that this path actually exists,\n        // and that it still refers to the same node.\n\n        if (!Editor.hasPath(editor, path) || Node.get(editor, path) !== node) {\n          return;\n        }\n\n        if (event.detail === TRIPLE_CLICK && path.length >= 1) {\n          var blockPath = path;\n\n          if (!Editor.isBlock(editor, node)) {\n            var _block$;\n\n            var block = Editor.above(editor, {\n              match: n => Editor.isBlock(editor, n),\n              at: path\n            });\n            blockPath = (_block$ = block === null || block === void 0 ? void 0 : block[1]) !== null && _block$ !== void 0 ? _block$ : path.slice(0, 1);\n          }\n\n          var range = Editor.range(editor, blockPath);\n          Transforms.select(editor, range);\n          return;\n        }\n\n        if (readOnly) {\n          return;\n        }\n\n        var _start = Editor.start(editor, path);\n\n        var end = Editor.end(editor, path);\n        var startVoid = Editor.void(editor, {\n          at: _start\n        });\n        var endVoid = Editor.void(editor, {\n          at: end\n        });\n\n        if (startVoid && endVoid && Path.equals(startVoid[1], endVoid[1])) {\n          var _range = Editor.range(editor, _start);\n\n          Transforms.select(editor, _range);\n        }\n      }\n    }, [readOnly, attributes.onClick]),\n    onCompositionEnd: useCallback(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n        if (ReactEditor.isComposing(editor)) {\n          setIsComposing(false);\n          IS_COMPOSING.set(editor, false);\n        }\n\n        androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleCompositionEnd(event);\n\n        if (isEventHandled(event, attributes.onCompositionEnd) || IS_ANDROID) {\n          return;\n        } // COMPAT: In Chrome, `beforeinput` events for compositions\n        // aren't correct and never fire the \"insertFromComposition\"\n        // type that we need. So instead, insert whenever a composition\n        // ends since it will already have been committed to the DOM.\n\n\n        if (!IS_SAFARI && !IS_FIREFOX_LEGACY && !IS_IOS && !IS_QQBROWSER && !IS_WECHATBROWSER && !IS_UC_MOBILE && event.data) {\n          var placeholderMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n          EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor); // Ensure we insert text with the marks the user was actually seeing\n\n          if (placeholderMarks !== undefined) {\n            EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n            editor.marks = placeholderMarks;\n          }\n\n          Editor.insertText(editor, event.data);\n          var userMarks = EDITOR_TO_USER_MARKS.get(editor);\n          EDITOR_TO_USER_MARKS.delete(editor);\n\n          if (userMarks !== undefined) {\n            editor.marks = userMarks;\n          }\n        }\n      }\n    }, [attributes.onCompositionEnd]),\n    onCompositionUpdate: useCallback(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {\n        if (!ReactEditor.isComposing(editor)) {\n          setIsComposing(true);\n          IS_COMPOSING.set(editor, true);\n        }\n      }\n    }, [attributes.onCompositionUpdate]),\n    onCompositionStart: useCallback(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n        androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleCompositionStart(event);\n\n        if (isEventHandled(event, attributes.onCompositionStart) || IS_ANDROID) {\n          return;\n        }\n\n        setIsComposing(true);\n        var {\n          selection\n        } = editor;\n\n        if (selection) {\n          if (Range.isExpanded(selection)) {\n            Editor.deleteFragment(editor);\n            return;\n          }\n\n          var inline = Editor.above(editor, {\n            match: n => Editor.isInline(editor, n),\n            mode: 'highest'\n          });\n\n          if (inline) {\n            var [, inlinePath] = inline;\n\n            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {\n              var point = Editor.after(editor, inlinePath);\n              Transforms.setSelection(editor, {\n                anchor: point,\n                focus: point\n              });\n            }\n          }\n        }\n      }\n    }, [attributes.onCompositionStart]),\n    onCopy: useCallback(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy)) {\n        event.preventDefault();\n        ReactEditor.setFragmentData(editor, event.clipboardData, 'copy');\n      }\n    }, [attributes.onCopy]),\n    onCut: useCallback(event => {\n      if (!readOnly && ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut)) {\n        event.preventDefault();\n        ReactEditor.setFragmentData(editor, event.clipboardData, 'cut');\n        var {\n          selection\n        } = editor;\n\n        if (selection) {\n          if (Range.isExpanded(selection)) {\n            Editor.deleteFragment(editor);\n          } else {\n            var node = Node.parent(editor, selection.anchor.path);\n\n            if (Editor.isVoid(editor, node)) {\n              Transforms.delete(editor);\n            }\n          }\n        }\n      }\n    }, [readOnly, attributes.onCut]),\n    onDragOver: useCallback(event => {\n      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {\n        // Only when the target is void, call `preventDefault` to signal\n        // that drops are allowed. Editable content is droppable by\n        // default, and calling `preventDefault` hides the cursor.\n        var node = ReactEditor.toSlateNode(editor, event.target);\n\n        if (Editor.isVoid(editor, node)) {\n          event.preventDefault();\n        }\n      }\n    }, [attributes.onDragOver]),\n    onDragStart: useCallback(event => {\n      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node);\n        var voidMatch = Editor.isVoid(editor, node) || Editor.void(editor, {\n          at: path,\n          voids: true\n        }); // If starting a drag on a void node, make sure it is selected\n        // so that it shows up in the selection's fragment.\n\n        if (voidMatch) {\n          var range = Editor.range(editor, path);\n          Transforms.select(editor, range);\n        }\n\n        state.isDraggingInternally = true;\n        ReactEditor.setFragmentData(editor, event.dataTransfer, 'drag');\n      }\n    }, [readOnly, attributes.onDragStart]),\n    onDrop: useCallback(event => {\n      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDrop)) {\n        event.preventDefault(); // Keep a reference to the dragged range before updating selection\n\n        var draggedRange = editor.selection; // Find the range where the drop happened\n\n        var range = ReactEditor.findEventRange(editor, event);\n        var data = event.dataTransfer;\n        Transforms.select(editor, range);\n\n        if (state.isDraggingInternally) {\n          if (draggedRange && !Range.equals(draggedRange, range) && !Editor.void(editor, {\n            at: range,\n            voids: true\n          })) {\n            Transforms.delete(editor, {\n              at: draggedRange\n            });\n          }\n        }\n\n        ReactEditor.insertData(editor, data); // When dragging from another source into the editor, it's possible\n        // that the current editor does not have focus.\n\n        if (!ReactEditor.isFocused(editor)) {\n          ReactEditor.focus(editor);\n        }\n      }\n\n      state.isDraggingInternally = false;\n    }, [readOnly, attributes.onDrop]),\n    onDragEnd: useCallback(event => {\n      if (!readOnly && state.isDraggingInternally && attributes.onDragEnd && ReactEditor.hasTarget(editor, event.target)) {\n        attributes.onDragEnd(event);\n      } // When dropping on a different droppable element than the current editor,\n      // `onDrop` is not called. So we need to clean up in `onDragEnd` instead.\n      // Note: `onDragEnd` is only called when `onDrop` is not called\n\n\n      state.isDraggingInternally = false;\n    }, [readOnly, attributes.onDragEnd]),\n    onFocus: useCallback(event => {\n      if (!readOnly && !state.isUpdatingSelection && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {\n        var el = ReactEditor.toDOMNode(editor, editor);\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        state.latestElement = root.activeElement; // COMPAT: If the editor has nested editable elements, the focus\n        // can go to them. In Firefox, this must be prevented because it\n        // results in issues with keyboard navigation. (2017/03/30)\n\n        if (IS_FIREFOX && event.target !== el) {\n          el.focus();\n          return;\n        }\n\n        IS_FOCUSED.set(editor, true);\n      }\n    }, [readOnly, attributes.onFocus]),\n    onKeyDown: useCallback(event => {\n      if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target)) {\n        androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleKeyDown(event);\n        var {\n          nativeEvent\n        } = event; // COMPAT: The composition end event isn't fired reliably in all browsers,\n        // so we sometimes might end up stuck in a composition state even though we\n        // aren't composing any more.\n\n        if (ReactEditor.isComposing(editor) && nativeEvent.isComposing === false) {\n          IS_COMPOSING.set(editor, false);\n          setIsComposing(false);\n        }\n\n        if (isEventHandled(event, attributes.onKeyDown) || ReactEditor.isComposing(editor)) {\n          return;\n        }\n\n        var {\n          selection\n        } = editor;\n        var element = editor.children[selection !== null ? selection.focus.path[0] : 0];\n        var isRTL = getDirection(Node.string(element)) === 'rtl'; // COMPAT: Since we prevent the default behavior on\n        // `beforeinput` events, the browser doesn't think there's ever\n        // any history stack to undo or redo, so we have to manage these\n        // hotkeys ourselves. (2019/11/06)\n\n        if (Hotkeys.isRedo(nativeEvent)) {\n          event.preventDefault();\n          var maybeHistoryEditor = editor;\n\n          if (typeof maybeHistoryEditor.redo === 'function') {\n            maybeHistoryEditor.redo();\n          }\n\n          return;\n        }\n\n        if (Hotkeys.isUndo(nativeEvent)) {\n          event.preventDefault();\n          var _maybeHistoryEditor = editor;\n\n          if (typeof _maybeHistoryEditor.undo === 'function') {\n            _maybeHistoryEditor.undo();\n          }\n\n          return;\n        } // COMPAT: Certain browsers don't handle the selection updates\n        // properly. In Chrome, the selection isn't properly extended.\n        // And in Firefox, the selection isn't properly collapsed.\n        // (2017/10/17)\n\n\n        if (Hotkeys.isMoveLineBackward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'line',\n            reverse: true\n          });\n          return;\n        }\n\n        if (Hotkeys.isMoveLineForward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'line'\n          });\n          return;\n        }\n\n        if (Hotkeys.isExtendLineBackward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'line',\n            edge: 'focus',\n            reverse: true\n          });\n          return;\n        }\n\n        if (Hotkeys.isExtendLineForward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'line',\n            edge: 'focus'\n          });\n          return;\n        } // COMPAT: If a void node is selected, or a zero-width text node\n        // adjacent to an inline is selected, we need to handle these\n        // hotkeys manually because browsers won't be able to skip over\n        // the void node with the zero-width space not being an empty\n        // string.\n\n\n        if (Hotkeys.isMoveBackward(nativeEvent)) {\n          event.preventDefault();\n\n          if (selection && Range.isCollapsed(selection)) {\n            Transforms.move(editor, {\n              reverse: !isRTL\n            });\n          } else {\n            Transforms.collapse(editor, {\n              edge: 'start'\n            });\n          }\n\n          return;\n        }\n\n        if (Hotkeys.isMoveForward(nativeEvent)) {\n          event.preventDefault();\n\n          if (selection && Range.isCollapsed(selection)) {\n            Transforms.move(editor, {\n              reverse: isRTL\n            });\n          } else {\n            Transforms.collapse(editor, {\n              edge: 'end'\n            });\n          }\n\n          return;\n        }\n\n        if (Hotkeys.isMoveWordBackward(nativeEvent)) {\n          event.preventDefault();\n\n          if (selection && Range.isExpanded(selection)) {\n            Transforms.collapse(editor, {\n              edge: 'focus'\n            });\n          }\n\n          Transforms.move(editor, {\n            unit: 'word',\n            reverse: !isRTL\n          });\n          return;\n        }\n\n        if (Hotkeys.isMoveWordForward(nativeEvent)) {\n          event.preventDefault();\n\n          if (selection && Range.isExpanded(selection)) {\n            Transforms.collapse(editor, {\n              edge: 'focus'\n            });\n          }\n\n          Transforms.move(editor, {\n            unit: 'word',\n            reverse: isRTL\n          });\n          return;\n        } // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n        // fall back to guessing at the input intention for hotkeys.\n        // COMPAT: In iOS, some of these hotkeys are handled in the\n\n\n        if (!HAS_BEFORE_INPUT_SUPPORT) {\n          // We don't have a core behavior for these, but they change the\n          // DOM if we don't prevent them, so we have to.\n          if (Hotkeys.isBold(nativeEvent) || Hotkeys.isItalic(nativeEvent) || Hotkeys.isTransposeCharacter(nativeEvent)) {\n            event.preventDefault();\n            return;\n          }\n\n          if (Hotkeys.isSoftBreak(nativeEvent)) {\n            event.preventDefault();\n            Editor.insertSoftBreak(editor);\n            return;\n          }\n\n          if (Hotkeys.isSplitBlock(nativeEvent)) {\n            event.preventDefault();\n            Editor.insertBreak(editor);\n            return;\n          }\n\n          if (Hotkeys.isDeleteBackward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              Editor.deleteBackward(editor);\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteForward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              Editor.deleteForward(editor);\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteLineBackward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              Editor.deleteBackward(editor, {\n                unit: 'line'\n              });\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteLineForward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              Editor.deleteForward(editor, {\n                unit: 'line'\n              });\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteWordBackward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              Editor.deleteBackward(editor, {\n                unit: 'word'\n              });\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteWordForward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              Editor.deleteForward(editor, {\n                unit: 'word'\n              });\n            }\n\n            return;\n          }\n        } else {\n          if (IS_CHROME || IS_SAFARI) {\n            // COMPAT: Chrome and Safari support `beforeinput` event but do not fire\n            // an event when deleting backwards in a selected void inline node\n            if (selection && (Hotkeys.isDeleteBackward(nativeEvent) || Hotkeys.isDeleteForward(nativeEvent)) && Range.isCollapsed(selection)) {\n              var currentNode = Node.parent(editor, selection.anchor.path);\n\n              if (Element$1.isElement(currentNode) && Editor.isVoid(editor, currentNode) && (Editor.isInline(editor, currentNode) || Editor.isBlock(editor, currentNode))) {\n                event.preventDefault();\n                Editor.deleteBackward(editor, {\n                  unit: 'block'\n                });\n                return;\n              }\n            }\n          }\n        }\n      }\n    }, [readOnly, attributes.onKeyDown]),\n    onPaste: useCallback(event => {\n      if (!readOnly && ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste)) {\n        // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n        // fall back to React's `onPaste` here instead.\n        // COMPAT: Firefox, Chrome and Safari don't emit `beforeinput` events\n        // when \"paste without formatting\" is used, so fallback. (2020/02/20)\n        if (!HAS_BEFORE_INPUT_SUPPORT || isPlainTextOnlyPaste(event.nativeEvent)) {\n          event.preventDefault();\n          ReactEditor.insertData(editor, event.clipboardData);\n        }\n      }\n    }, [readOnly, attributes.onPaste])\n  }), /*#__PURE__*/React.createElement(Children, {\n    decorations: decorations,\n    node: editor,\n    renderElement: renderElement,\n    renderPlaceholder: renderPlaceholder,\n    renderLeaf: renderLeaf,\n    selection: editor.selection\n  })))));\n};\n/**\r\n * The default placeholder element\r\n */\n\nvar DefaultPlaceholder = _ref => {\n  var {\n    attributes,\n    children\n  } = _ref;\n  return (\n    /*#__PURE__*/\n    // COMPAT: Artificially add a line-break to the end on the placeholder element\n    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter\n    React.createElement(\"span\", Object.assign({}, attributes), children, IS_ANDROID && /*#__PURE__*/React.createElement(\"br\", null))\n  );\n};\n/**\r\n * A default memoized decorate function.\r\n */\n\nvar defaultDecorate = () => [];\n/**\r\n * A default implement to scroll dom range into view.\r\n */\n\nvar defaultScrollSelectionIntoView = (editor, domRange) => {\n  // This was affecting the selection of multiple blocks and dragging behavior,\n  // so enabled only if the selection has been collapsed.\n  if (domRange.getBoundingClientRect && (!editor.selection || editor.selection && Range.isCollapsed(editor.selection))) {\n    var leafEl = domRange.startContainer.parentElement;\n    leafEl.getBoundingClientRect = domRange.getBoundingClientRect.bind(domRange);\n    scrollIntoView(leafEl, {\n      scrollMode: 'if-needed'\n    }); // @ts-expect-error an unorthodox delete D:\n\n    delete leafEl.getBoundingClientRect;\n  }\n};\n/**\r\n * Check if an event is overrided by a handler.\r\n */\n\n\nvar isEventHandled = (event, handler) => {\n  if (!handler) {\n    return false;\n  } // The custom event handler may return a boolean to specify whether the event\n  // shall be treated as being handled or not.\n\n\n  var shouldTreatEventAsHandled = handler(event);\n\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled;\n  }\n\n  return event.isDefaultPrevented() || event.isPropagationStopped();\n};\n/**\r\n * Check if a DOM event is overrided by a handler.\r\n */\n\nvar isDOMEventHandled = (event, handler) => {\n  if (!handler) {\n    return false;\n  } // The custom event handler may return a boolean to specify whether the event\n  // shall be treated as being handled or not.\n\n\n  var shouldTreatEventAsHandled = handler(event);\n\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled;\n  }\n\n  return event.defaultPrevented;\n};\n\n/**\r\n * A React context for sharing the `focused` state of the editor.\r\n */\n\nvar FocusedContext = /*#__PURE__*/createContext(false);\n/**\r\n * Get the current `focused` state of the editor.\r\n */\n\nvar useFocused = () => {\n  return useContext(FocusedContext);\n};\n\nfunction isError(error) {\n  return error instanceof Error;\n}\n/**\r\n * A React context for sharing the editor selector context in a way to control rerenders\r\n */\n\n\nvar SlateSelectorContext = /*#__PURE__*/createContext({});\n\nvar refEquality = (a, b) => a === b;\n/**\r\n * use redux style selectors to prevent rerendering on every keystroke.\r\n * Bear in mind rerendering can only prevented if the returned value is a value type or for reference types (e.g. objects and arrays) add a custom equality function.\r\n *\r\n * Example:\r\n * ```\r\n *  const isSelectionActive = useSlateSelector(editor => Boolean(editor.selection));\r\n * ```\r\n */\n\n\nfunction useSlateSelector(selector) {\n  var equalityFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : refEquality;\n  var [, forceRender] = useReducer(s => s + 1, 0);\n  var context = useContext(SlateSelectorContext);\n\n  if (!context) {\n    throw new Error(\"The `useSlateSelector` hook must be used inside the <Slate> component's context.\");\n  }\n\n  var {\n    getSlate,\n    addEventListener\n  } = context;\n  var latestSubscriptionCallbackError = useRef();\n  var latestSelector = useRef(() => null);\n  var latestSelectedState = useRef(null);\n  var selectedState;\n\n  try {\n    if (selector !== latestSelector.current || latestSubscriptionCallbackError.current) {\n      selectedState = selector(getSlate());\n    } else {\n      selectedState = latestSelectedState.current;\n    }\n  } catch (err) {\n    if (latestSubscriptionCallbackError.current && isError(err)) {\n      err.message += \"\\nThe error may be correlated with this previous error:\\n\".concat(latestSubscriptionCallbackError.current.stack, \"\\n\\n\");\n    }\n\n    throw err;\n  }\n\n  useIsomorphicLayoutEffect(() => {\n    latestSelector.current = selector;\n    latestSelectedState.current = selectedState;\n    latestSubscriptionCallbackError.current = undefined;\n  });\n  useIsomorphicLayoutEffect(() => {\n    function checkForUpdates() {\n      try {\n        var newSelectedState = latestSelector.current(getSlate());\n\n        if (equalityFn(newSelectedState, latestSelectedState.current)) {\n          return;\n        }\n\n        latestSelectedState.current = newSelectedState;\n      } catch (err) {\n        // we ignore all errors here, since when the component\n        // is re-rendered, the selectors are called again, and\n        // will throw again, if neither props nor store state\n        // changed\n        latestSubscriptionCallbackError.current = err;\n      }\n\n      forceRender();\n    }\n\n    var unsubscribe = addEventListener(checkForUpdates);\n    checkForUpdates();\n    return () => unsubscribe();\n  }, // don't rerender on equalityFn change since we want to be able to define it inline\n  [addEventListener, getSlate]);\n  return selectedState;\n}\n/**\r\n * Create selector context with editor updating on every editor change\r\n */\n\nfunction getSelectorContext(editor) {\n  var eventListeners = useRef([]).current;\n  var slateRef = useRef({\n    editor\n  }).current;\n  var onChange = useCallback(editor => {\n    slateRef.editor = editor;\n    eventListeners.forEach(listener => listener(editor));\n  }, []);\n  var selectorContext = useMemo(() => {\n    return {\n      getSlate: () => slateRef.editor,\n      addEventListener: callback => {\n        eventListeners.push(callback);\n        return () => {\n          eventListeners.splice(eventListeners.indexOf(callback), 1);\n        };\n      }\n    };\n  }, [eventListeners, slateRef]);\n  return {\n    selectorContext,\n    onChange\n  };\n}\n\nvar _excluded = [\"editor\", \"children\", \"onChange\", \"value\"];\n/**\r\n * A wrapper around the provider to handle `onChange` events, because the editor\r\n * is a mutable singleton so it won't ever register as \"changed\" otherwise.\r\n */\n\nvar Slate = props => {\n  var {\n    editor,\n    children,\n    onChange,\n    value\n  } = props,\n      rest = _objectWithoutProperties(props, _excluded);\n\n  var unmountRef = useRef(false);\n  var [context, setContext] = React.useState(() => {\n    if (!Node.isNodeList(value)) {\n      throw new Error(\"[Slate] value is invalid! Expected a list of elements but got: \".concat(Scrubber.stringify(value)));\n    }\n\n    if (!Editor.isEditor(editor)) {\n      throw new Error(\"[Slate] editor is invalid! You passed: \".concat(Scrubber.stringify(editor)));\n    }\n\n    editor.children = value;\n    Object.assign(editor, rest);\n    return {\n      v: 0,\n      editor\n    };\n  });\n  var {\n    selectorContext,\n    onChange: handleSelectorChange\n  } = getSelectorContext(editor);\n  var onContextChange = useCallback(() => {\n    if (onChange) {\n      onChange(editor.children);\n    }\n\n    setContext(prevContext => ({\n      v: prevContext.v + 1,\n      editor\n    }));\n    handleSelectorChange(editor);\n  }, [onChange]);\n  EDITOR_TO_ON_CHANGE.set(editor, onContextChange);\n  useEffect(() => {\n    return () => {\n      EDITOR_TO_ON_CHANGE.set(editor, () => {});\n      unmountRef.current = true;\n    };\n  }, []);\n  var [isFocused, setIsFocused] = useState(ReactEditor.isFocused(editor));\n  useEffect(() => {\n    setIsFocused(ReactEditor.isFocused(editor));\n  });\n  useIsomorphicLayoutEffect(() => {\n    var fn = () => setIsFocused(ReactEditor.isFocused(editor));\n\n    if (IS_REACT_VERSION_17_OR_ABOVE) {\n      // In React >= 17 onFocus and onBlur listen to the focusin and focusout events during the bubbling phase.\n      // Therefore in order for <Editable />'s handlers to run first, which is necessary for ReactEditor.isFocused(editor)\n      // to return the correct value, we have to listen to the focusin and focusout events without useCapture here.\n      document.addEventListener('focusin', fn);\n      document.addEventListener('focusout', fn);\n      return () => {\n        document.removeEventListener('focusin', fn);\n        document.removeEventListener('focusout', fn);\n      };\n    } else {\n      document.addEventListener('focus', fn, true);\n      document.addEventListener('blur', fn, true);\n      return () => {\n        document.removeEventListener('focus', fn, true);\n        document.removeEventListener('blur', fn, true);\n      };\n    }\n  }, []);\n  return /*#__PURE__*/React.createElement(SlateSelectorContext.Provider, {\n    value: selectorContext\n  }, /*#__PURE__*/React.createElement(SlateContext.Provider, {\n    value: context\n  }, /*#__PURE__*/React.createElement(EditorContext.Provider, {\n    value: context.editor\n  }, /*#__PURE__*/React.createElement(FocusedContext.Provider, {\n    value: isFocused\n  }, children))));\n};\n\n/**\r\n * Get the current editor object from the React context.\r\n * @deprecated Use useSlateStatic instead.\r\n */\n\nvar useEditor = () => {\n  var editor = useContext(EditorContext);\n\n  if (!editor) {\n    throw new Error(\"The `useEditor` hook must be used inside the <Slate> component's context.\");\n  }\n\n  return editor;\n};\n\n/**\r\n * Get the current slate selection.\r\n * Only triggers a rerender when the selection actually changes\r\n */\n\nvar useSlateSelection = () => {\n  return useSlateSelector(editor => editor.selection, isSelectionEqual);\n};\n\nvar isSelectionEqual = (a, b) => {\n  if (!a && !b) return true;\n  if (!a || !b) return false;\n  return Range.equals(a, b);\n};\n\n/**\r\n * Utilities for single-line deletion\r\n */\n\nvar doRectsIntersect = (rect, compareRect) => {\n  var middle = (compareRect.top + compareRect.bottom) / 2;\n  return rect.top <= middle && rect.bottom >= middle;\n};\n\nvar areRangesSameLine = (editor, range1, range2) => {\n  var rect1 = ReactEditor.toDOMRange(editor, range1).getBoundingClientRect();\n  var rect2 = ReactEditor.toDOMRange(editor, range2).getBoundingClientRect();\n  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);\n};\n/**\r\n * A helper utility that returns the end portion of a `Range`\r\n * which is located on a single line.\r\n *\r\n * @param {Editor} editor The editor object to compare against\r\n * @param {Range} parentRange The parent range to compare against\r\n * @returns {Range} A valid portion of the parentRange which is one a single line\r\n */\n\n\nvar findCurrentLineRange = (editor, parentRange) => {\n  var parentRangeBoundary = Editor.range(editor, Range.end(parentRange));\n  var positions = Array.from(Editor.positions(editor, {\n    at: parentRange\n  }));\n  var left = 0;\n  var right = positions.length;\n  var middle = Math.floor(right / 2);\n\n  if (areRangesSameLine(editor, Editor.range(editor, positions[left]), parentRangeBoundary)) {\n    return Editor.range(editor, positions[left], parentRangeBoundary);\n  }\n\n  if (positions.length < 2) {\n    return Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);\n  }\n\n  while (middle !== positions.length && middle !== left) {\n    if (areRangesSameLine(editor, Editor.range(editor, positions[middle]), parentRangeBoundary)) {\n      right = middle;\n    } else {\n      left = middle;\n    }\n\n    middle = Math.floor((left + right) / 2);\n  }\n\n  return Editor.range(editor, positions[right], parentRangeBoundary);\n};\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n/**\r\n * `withReact` adds React and DOM specific behaviors to the editor.\r\n *\r\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\r\n * this plugin.\r\n *\r\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\r\n */\n\nvar withReact = editor => {\n  var e = editor;\n  var {\n    apply,\n    onChange,\n    deleteBackward,\n    addMark,\n    removeMark\n  } = e; // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to\n  // avoid collisions between editors in the DOM that share the same value.\n\n  EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap());\n\n  e.addMark = (key, value) => {\n    var _EDITOR_TO_SCHEDULE_F, _EDITOR_TO_PENDING_DI;\n\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(e)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();\n\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n\n    EDITOR_TO_USER_MARKS.delete(e);\n    addMark(key, value);\n  };\n\n  e.removeMark = key => {\n    var _EDITOR_TO_PENDING_DI2;\n\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI2 !== void 0 && _EDITOR_TO_PENDING_DI2.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n\n    EDITOR_TO_USER_MARKS.delete(e);\n    removeMark(key);\n  };\n\n  e.deleteBackward = unit => {\n    if (unit !== 'line') {\n      return deleteBackward(unit);\n    }\n\n    if (e.selection && Range.isCollapsed(e.selection)) {\n      var parentBlockEntry = Editor.above(e, {\n        match: n => Editor.isBlock(e, n),\n        at: e.selection\n      });\n\n      if (parentBlockEntry) {\n        var [, parentBlockPath] = parentBlockEntry;\n        var parentElementRange = Editor.range(e, parentBlockPath, e.selection.anchor);\n        var currentLineRange = findCurrentLineRange(e, parentElementRange);\n\n        if (!Range.isCollapsed(currentLineRange)) {\n          Transforms.delete(e, {\n            at: currentLineRange\n          });\n        }\n      }\n    }\n  }; // This attempts to reset the NODE_TO_KEY entry to the correct value\n  // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry\n\n\n  e.apply = op => {\n    var matches = [];\n    var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e);\n\n    if (pendingDiffs !== null && pendingDiffs !== void 0 && pendingDiffs.length) {\n      var transformed = pendingDiffs.map(textDiff => transformTextDiff(textDiff, op)).filter(Boolean);\n      EDITOR_TO_PENDING_DIFFS.set(e, transformed);\n    }\n\n    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e);\n\n    if (pendingSelection) {\n      EDITOR_TO_PENDING_SELECTION.set(e, transformPendingRange(e, pendingSelection, op));\n    }\n\n    var pendingAction = EDITOR_TO_PENDING_ACTION.get(e);\n\n    if (pendingAction !== null && pendingAction !== void 0 && pendingAction.at) {\n      var at = Point.isPoint(pendingAction === null || pendingAction === void 0 ? void 0 : pendingAction.at) ? transformPendingPoint(e, pendingAction.at, op) : transformPendingRange(e, pendingAction.at, op);\n      EDITOR_TO_PENDING_ACTION.set(e, at ? _objectSpread(_objectSpread({}, pendingAction), {}, {\n        at\n      }) : null);\n    }\n\n    switch (op.type) {\n      case 'insert_text':\n      case 'remove_text':\n      case 'set_node':\n      case 'split_node':\n        {\n          matches.push(...getMatches(e, op.path));\n          break;\n        }\n\n      case 'set_selection':\n        {\n          var _EDITOR_TO_USER_SELEC;\n\n          // Selection was manually set, don't restore the user selection after the change.\n          (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(e)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();\n          EDITOR_TO_USER_SELECTION.delete(e);\n          break;\n        }\n\n      case 'insert_node':\n      case 'remove_node':\n        {\n          matches.push(...getMatches(e, Path.parent(op.path)));\n          break;\n        }\n\n      case 'merge_node':\n        {\n          var prevPath = Path.previous(op.path);\n          matches.push(...getMatches(e, prevPath));\n          break;\n        }\n\n      case 'move_node':\n        {\n          var commonPath = Path.common(Path.parent(op.path), Path.parent(op.newPath));\n          matches.push(...getMatches(e, commonPath));\n          break;\n        }\n    }\n\n    apply(op);\n\n    for (var [path, key] of matches) {\n      var [node] = Editor.node(e, path);\n      NODE_TO_KEY.set(node, key);\n    }\n  };\n\n  e.setFragmentData = data => {\n    var {\n      selection\n    } = e;\n\n    if (!selection) {\n      return;\n    }\n\n    var [start, end] = Range.edges(selection);\n    var startVoid = Editor.void(e, {\n      at: start.path\n    });\n    var endVoid = Editor.void(e, {\n      at: end.path\n    });\n\n    if (Range.isCollapsed(selection) && !startVoid) {\n      return;\n    } // Create a fake selection so that we can add a Base64-encoded copy of the\n    // fragment to the HTML, to decode on future pastes.\n\n\n    var domRange = ReactEditor.toDOMRange(e, selection);\n    var contents = domRange.cloneContents();\n    var attach = contents.childNodes[0]; // Make sure attach is non-empty, since empty nodes will not get copied.\n\n    contents.childNodes.forEach(node => {\n      if (node.textContent && node.textContent.trim() !== '') {\n        attach = node;\n      }\n    }); // COMPAT: If the end node is a void node, we need to move the end of the\n    // range from the void node's spacer span, to the end of the void node's\n    // content, since the spacer is before void's content in the DOM.\n\n    if (endVoid) {\n      var [voidNode] = endVoid;\n      var r = domRange.cloneRange();\n      var domNode = ReactEditor.toDOMNode(e, voidNode);\n      r.setEndAfter(domNode);\n      contents = r.cloneContents();\n    } // COMPAT: If the start node is a void node, we need to attach the encoded\n    // fragment to the void node's content node instead of the spacer, because\n    // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n    // most browsers. (2018/04/27)\n\n\n    if (startVoid) {\n      attach = contents.querySelector('[data-slate-spacer]');\n    } // Remove any zero-width space spans from the cloned DOM so that they don't\n    // show up elsewhere when pasted.\n\n\n    Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(zw => {\n      var isNewline = zw.getAttribute('data-slate-zero-width') === 'n';\n      zw.textContent = isNewline ? '\\n' : '';\n    }); // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n    // in the HTML, and can be used for intra-Slate pasting. If it's a text\n    // node, wrap it in a `<span>` so we have something to set an attribute on.\n\n    if (isDOMText(attach)) {\n      var span = attach.ownerDocument.createElement('span'); // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n      // then leading and trailing spaces will be ignored. (2017/09/21)\n\n      span.style.whiteSpace = 'pre';\n      span.appendChild(attach);\n      contents.appendChild(span);\n      attach = span;\n    }\n\n    var fragment = e.getFragment();\n    var string = JSON.stringify(fragment);\n    var encoded = window.btoa(encodeURIComponent(string));\n    attach.setAttribute('data-slate-fragment', encoded);\n    data.setData('application/x-slate-fragment', encoded); // Add the content to a <div> so that we can get its inner HTML.\n\n    var div = contents.ownerDocument.createElement('div');\n    div.appendChild(contents);\n    div.setAttribute('hidden', 'true');\n    contents.ownerDocument.body.appendChild(div);\n    data.setData('text/html', div.innerHTML);\n    data.setData('text/plain', getPlainText(div));\n    contents.ownerDocument.body.removeChild(div);\n    return data;\n  };\n\n  e.insertData = data => {\n    if (!e.insertFragmentData(data)) {\n      e.insertTextData(data);\n    }\n  };\n\n  e.insertFragmentData = data => {\n    /**\r\n     * Checking copied fragment from application/x-slate-fragment or data-slate-fragment\r\n     */\n    var fragment = data.getData('application/x-slate-fragment') || getSlateFragmentAttribute(data);\n\n    if (fragment) {\n      var decoded = decodeURIComponent(window.atob(fragment));\n      var parsed = JSON.parse(decoded);\n      e.insertFragment(parsed);\n      return true;\n    }\n\n    return false;\n  };\n\n  e.insertTextData = data => {\n    var text = data.getData('text/plain');\n\n    if (text) {\n      var lines = text.split(/\\r\\n|\\r|\\n/);\n      var split = false;\n\n      for (var line of lines) {\n        if (split) {\n          Transforms.splitNodes(e, {\n            always: true\n          });\n        }\n\n        e.insertText(line);\n        split = true;\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n\n  e.onChange = () => {\n    // COMPAT: React doesn't batch `setState` hook calls, which means that the\n    // children and selection can get out of sync for one render pass. So we\n    // have to use this unstable API to ensure it batches them. (2019/12/03)\n    // https://github.com/facebook/react/issues/14259#issuecomment-439702367\n    ReactDOM.unstable_batchedUpdates(() => {\n      var onContextChange = EDITOR_TO_ON_CHANGE.get(e);\n\n      if (onContextChange) {\n        onContextChange();\n      }\n\n      onChange();\n    });\n  };\n\n  return e;\n};\n\nvar getMatches = (e, path) => {\n  var matches = [];\n\n  for (var [n, p] of Editor.levels(e, {\n    at: path\n  })) {\n    var key = ReactEditor.findKey(e, n);\n    matches.push([p, key]);\n  }\n\n  return matches;\n};\n\nexport { DefaultElement, DefaultLeaf, DefaultPlaceholder, Editable, ReactEditor, Slate, useEditor, useFocused, useReadOnly, useSelected, useSlate, useSlateSelection, useSlateSelector, useSlateStatic, useSlateWithV, withReact };\n//# sourceMappingURL=index.es.js.map\n"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","_objectWithoutProperties","source","excluded","i","target","sourceKeys","keys","length","indexOf","_objectWithoutPropertiesLoose","getOwnPropertySymbols","sourceSymbolKeys","prototype","propertyIsEnumerable","call","n","Key","constructor","this","id","concat","NODE_TO_INDEX","WeakMap","NODE_TO_PARENT","EDITOR_TO_WINDOW","EDITOR_TO_ELEMENT","EDITOR_TO_PLACEHOLDER_ELEMENT","ELEMENT_TO_NODE","NODE_TO_ELEMENT","NODE_TO_KEY","EDITOR_TO_KEY_TO_ELEMENT","EDITOR_TO_STYLE_ELEMENT","IS_READ_ONLY","IS_FOCUSED","IS_COMPOSING","EDITOR_TO_USER_SELECTION","EDITOR_TO_ON_CHANGE","EDITOR_TO_SCHEDULE_FLUSH","EDITOR_TO_PENDING_INSERTION_MARKS","EDITOR_TO_USER_MARKS","EDITOR_TO_PENDING_DIFFS","EDITOR_TO_PENDING_ACTION","EDITOR_TO_PENDING_SELECTION","EDITOR_TO_FORCE_RENDER","PLACEHOLDER_SYMBOL","Symbol","MARK_PLACEHOLDER_SYMBOL","DOMText","globalThis","Text","getDefaultView","ownerDocument","defaultView","isDOMElement","isDOMNode","nodeType","window","Node","isDOMSelection","anchorNode","Selection","isDOMText","getEditableChildAndIndex","parent","index","direction","childNodes","child","triedForward","triedBackward","getAttribute","getEditableChild","getPlainText","domNode","text","nodeValue","childNode","Array","from","display","getComputedStyle","getPropertyValue","tagName","catchSlateFragment","isTrackedMutation","editor","mutation","batch","matches","document","ReactEditor","getWindow","contains","hasDOMNode","editable","parentMutation","find","_ref","addedNodes","removedNodes","node","_node","IS_REACT_VERSION_17_OR_ABOVE","parseInt","IS_IOS","navigator","test","userAgent","MSStream","IS_APPLE","IS_ANDROID","IS_FIREFOX","IS_SAFARI","IS_EDGE_LEGACY","IS_CHROME","IS_CHROME_LEGACY","IS_FIREFOX_LEGACY","IS_QQBROWSER","IS_UC_MOBILE","IS_WECHATBROWSER","CAN_USE_DOM","createElement","HAS_BEFORE_INPUT_SUPPORT","InputEvent","getTargetRanges","isComposing","get","Error","findKey","set","findPath","path","unshift","findDocumentOrShadowRoot","el","toDOMNode","root","getRootNode","Document","ShadowRoot","getSelection","isFocused","isReadOnly","blur","activeElement","focus","preventScroll","deselect","selection","domSelection","rangeCount","removeAllRanges","targetEl","options","arguments","undefined","editorEl","parentElement","err","message","includes","closest","isContentEditable","insertData","data","insertFragmentData","insertTextData","setFragmentData","originEvent","KEY_TO_ELEMENT","toDOMPoint","point","domPoint","at","offset","texts","querySelectorAll","start","textContent","attr","end","nextText","hasAttribute","_nextText$textContent","domText","startsWith","Math","min","max","toDOMRange","range","anchor","isBackward","domAnchor","domFocus","domRange","createRange","startNode","startOffset","endNode","endOffset","isStartAtZeroWidth","isEndAtZeroWidth","setStart","setEnd","toSlateNode","domEl","findEventRange","event","nativeEvent","clientX","x","clientY","y","rect","getBoundingClientRect","isPrev","isInline","left","width","top","height","edge","caretRangeFromPoint","position","caretPositionFromPoint","offsetNode","toSlateRange","exactMatch","suppressThrow","toSlatePoint","nearestNode","nearestOffset","isLast","normalizeDOMPoint","parentNode","textNode","_domNode$textContent","_domNode$textContent2","potentialVoidNode","voidNode","leafNode","contents","cloneContents","slice","forEach","textContext","removeChild","leafNodes","current","endsWith","_slateNode","_path","_offset","querySelector","slateNode","anchorOffset","focusNode","focusOffset","isCollapsed","startContainer","shadowRoot","endContainer","collapsed","mode","voids","hasRange","hasTarget","hasEditableTarget","hasSelectableTarget","isTargetInsideNonReadonlyVoid","androidScheduleFlush","_EDITOR_TO_SCHEDULE_F","androidPendingDiffs","useIsomorphicLayoutEffect","useLayoutEffect","useEffect","_excluded$3","_excluded2$1","shallowCompare","obj1","obj2","every","hasOwnProperty","isDecoratorRangeListEqual","list","another","other","rangeOwnProps","otherOwnProps","String","props","leaf","useSlateStatic","parentPath","isMarkPlaceholder","isVoid","ZeroWidthString","children","TextString","isTrailing","isLineBreak","ref","useRef","getTextContent","textWithTrailing","attributes","assign","EditorContext","createContext","useContext","Leaf","renderPlaceholder","renderLeaf","DefaultLeaf","placeholderRef","placeholderResizeObserver","disconnect","placeholderEl","delete","observe","ResizeObserver","styleElement","minHeight","clientHeight","innerHTML","placeholderProps","placeholder","style","pointerEvents","maxWidth","opacity","userSelect","textDecoration","contentEditable","MemoizedLeaf","prev","next","decorations","leaves","push","MemoizedText","Element","element","renderElement","p","DefaultElement","readOnly","useReadOnly","useCallback","useChildren","dir","Tag","_text","color","outline","MemoizedElement","DecorateContext","SelectedContext","useSelected","decorate","isLeafBlock","sel","ds","dec","d","Provider","ReadOnlyContext","SlateContext","HOTKEYS","bold","compose","moveBackward","moveForward","moveWordBackward","moveWordForward","deleteBackward","deleteForward","extendBackward","extendForward","italic","insertSoftBreak","splitBlock","undo","APPLE_HOTKEYS","moveLineBackward","moveLineForward","deleteLineBackward","deleteLineForward","deleteWordBackward","deleteWordForward","extendLineBackward","extendLineForward","redo","transposeCharacter","WINDOWS_HOTKEYS","create","generic","apple","windows","isGeneric","isApple","isWindows","Hotkeys","isBold","isCompose","isMoveBackward","isMoveForward","isDeleteBackward","isDeleteForward","isDeleteLineBackward","isDeleteLineForward","isDeleteWordBackward","isDeleteWordForward","isExtendBackward","isExtendForward","isExtendLineBackward","isExtendLineForward","isItalic","isMoveLineBackward","isMoveLineForward","isMoveWordBackward","isMoveWordForward","isRedo","isSoftBreak","isSplitBlock","isTransposeCharacter","isUndo","MUTATION_OBSERVER_CONFIG$1","subtree","childList","characterData","characterDataOldValue","RestoreDOMComponent","Component","super","context","manager","mutationObserver","_this$mutationObserve","componentDidMount","receivedUserInput","bufferedMutations","clear","registerMutations","mutations","trackedMutations","filter","restoreDOM","reverse","type","insertBefore","nextSibling","oldValue","createRestoreDomManager","MutationObserver","getSnapshotBeforeUpdate","_this$mutationObserve2","_this$mutationObserve3","_this$manager2","_this$manager","pendingMutations","takeRecords","componentDidUpdate","_this$manager3","componentWillUnmount","_this$mutationObserve4","render","contextType","RestoreDOM","verifyDiffState","textDiff","diff","nextPath","nextNode","normalizeStringDiff","targetText","removedText","prefixLength","str","charAt","longestCommonPrefixLength","suffixLength","longestCommonSuffixLength","normalized","mergeStringDiffs","a","b","overlap","applied","_len","diffs","_key","reduce","applyStringDiff","sliceEnd","targetRange","normalizePoint","parentBlock","match","entry","normalizeRange","transformPendingPoint","op","pendingDiffs","affinity","_anchor","_transformed","transformed","transformPendingRange","ownKeys$3","object","enumerableOnly","symbols","sym","getOwnPropertyDescriptor","apply","_objectSpread$3","getOwnPropertyDescriptors","defineProperties","createAndroidInputManager","scheduleOnDOMSelectionChange","onDOMSelectionChange","flushing","compositionEndTimeoutId","flushTimeoutId","actionTimeoutId","idCounter","insertPositionHint","applyPendingSelection","pendingSelection","flush","_EDITOR_TO_PENDING_DI","clearTimeout","hasPendingDiffs","hasPendingAction","setTimeout","selectionRef","marks","scheduleSelectionChange","_EDITOR_TO_PENDING_DI2","_EDITOR_TO_PENDING_DI3","pendingMarks","_ref2","cancel","unref","action","_targetRange","run","performAction","userMarks","onChange","updatePlaceholderVisibility","forceHide","placeholderElement","removeProperty","storeDiff","_EDITOR_TO_PENDING_DI4","idx","findIndex","change","merged","splice","scheduleAction","_EDITOR_TO_PENDING_DI5","scheduleFlush","hasPendingChanges","isFlushing","handleUserSelect","pathChanged","parentPathChanged","handleCompositionEnd","_event","handleCompositionStart","handleDOMBeforeInput","_targetRange2","inputType","dataTransfer","nativeTargetRange","_start","_end","targetNode","_nativeTargetRange","unit","name","replace","_start2","_end2","hintPosition","search","handleKeyDown","_","handleDomMutations","_EDITOR_TO_FORCE_REND","some","handleInput","_excluded$2","ownKeys$2","MUTATION_OBSERVER_CONFIG","useAndroidInputManager","isMounted","isMountedRef","useIsMounted","inputManager","useState","_objectSpread$2","callback","useMutationObserver","_excluded$1","_excluded2","ownKeys$1","_objectSpread$1","Children","mountedCount","Editable","autoFocus","defaultDecorate","onDOMBeforeInput","propsOnDOMBeforeInput","DefaultPlaceholder","scrollSelectionIntoView","defaultScrollSelectionIntoView","as","useSlate","setIsComposing","deferredOperations","onUserInput","animationFrameIdRef","cancelAnimationFrame","requestAnimationFrame","useTrackUserInput","forceRender","useReducer","s","state","useMemo","isDraggingInternally","isUpdatingSelection","latestElement","hasMarkPlaceholder","androidInputManager","anchorNodeSelectable","focusNodeSelectable","setDomSelection","forceChange","hasDomSelection","editorElement","hasDomSelectionInEditor","slateRange","_anchorNode$parentEle","newDomRange","setBaseAndExtent","ensureSelection","timeoutId","animationFrameId","ensureDomSelection","e","isDOMEventHandled","_EDITOR_TO_USER_SELEC","isCompositionChange","native","_node$parentElement","_window$getComputedSt","_lastText$textContent","lastText","createTreeWalker","NodeFilter","SHOW_TEXT","lastChild","whiteSpace","block","preventDefault","toRestore","addEventListener","removeEventListener","rest","loose","unset","fromEntries","map","mark","defaultStylesElement","setAttribute","head","appendChild","_document$querySelect","remove","role","spellCheck","autoCorrect","autoCapitalize","zindex","suppressContentEditableWarning","onBeforeInput","isEventHandled","_text2","onInput","onBlur","relatedTarget","onClick","detail","blockPath","_block$","startVoid","endVoid","_range","onCompositionEnd","placeholderMarks","onCompositionUpdate","onCompositionStart","inline","inlinePath","onCopy","clipboardData","onCut","onDragOver","onDragStart","onDrop","draggedRange","onDragEnd","onFocus","onKeyDown","isRTL","maybeHistoryEditor","_maybeHistoryEditor","currentNode","onPaste","getData","types","isPlainTextOnlyPaste","leafEl","bind","scrollMode","handler","shouldTreatEventAsHandled","isDefaultPrevented","isPropagationStopped","defaultPrevented","FocusedContext","useFocused","SlateSelectorContext","_excluded","Slate","unmountRef","setContext","v","selectorContext","handleSelectorChange","eventListeners","slateRef","listener","getSlate","getSelectorContext","onContextChange","prevContext","setIsFocused","fn","doRectsIntersect","compareRect","middle","bottom","areRangesSameLine","range1","range2","rect1","rect2","ownKeys","_objectSpread","withReact","addMark","removeMark","parentBlockEntry","parentBlockPath","parentElementRange","currentLineRange","parentRange","parentRangeBoundary","positions","right","floor","findCurrentLineRange","newPath","transformTextDiff","Boolean","pendingAction","getMatches","prevPath","commonPath","attach","trim","r","cloneRange","setEndAfter","zw","isNewline","span","fragment","getFragment","string","JSON","stringify","encoded","btoa","encodeURIComponent","setData","div","body","htmlData","getSlateFragmentAttribute","decoded","decodeURIComponent","atob","parsed","parse","insertFragment","lines","split","line","always","insertText"],"sourceRoot":""}